## translation metadata
# Based-On-Revision: 13843
# Last-Translator: jens@kubieziel.de, peter@palfrader.org

#include "head.wmi" TITLE="Mithelfen" 

<div class="main-column">

<!-- PUT CONTENT AFTER THIS TAG -->

<h2>Drei Sachen, die jeder tun kann</h2>

<ol>
  <li>Bitte überlege dir,
    einen <a href="<page docs/tor-doc-server>">Server zu
    betreiben</a>, damit das Netzwerk weiter wächst.</li>
  <li>Erzähl es deinen Freunden! Bringe sie dazu, auch Server zu
    betreiben.  Bringe sie dazu, auch versteckte Services zu
    betreiben. Bringe sie dazu, es wieder ihren Freunden zu
    erzählen.</li>
  <li>Wir suchen nach Sponsoren und Geldgebern. Wenn du die Ziele von Tor magst
    und es nützlich findest, <a href="<page donate>">nimm dir einen Moment Zeit
    und spende, um die weitere Entwicklung zu unterstützen</a>. Wenn du Firmen,
    <abbr title="Non-Governmental Organisations">NGO</abbr>s oder andere
    Organisationen, die Sicherheit in ihrer Kommunikation benötigen, kennst,
    lasse sie über uns wissen.</li>
  </ol>

<a id="Usability"></a>
<h2><a class="anchor" href="#Usability">unterstützende Anwendungen</a></h2>

<ol>
  <li>Wir brauchen einen guten Weg, um DNS-Abfragen abzufangen, damit diese
  nicht an einen lokalen Beobachter dringen, während wir versuchen, anonym zu
  bleiben. (Dies passiert, weil die Anwendung selbst DNS-Anfragen
  stellt, anstatt diese über Tor zu leiten.).
  <ul>
    <li>Wir müssen <a
    href="https://wiki.torproject.org/noreply/TheOnionRouter/TSocksPatches">all
    unsere Patches für tsocks</a> einspielen und einen Fork
    betreuen. Wir würden diesen auch auf unserem Server mit anbieten, wenn
    du möchtest.</li>
    <li>Wir sollten das Programm dsocks von Dug Song patchen, so dass es
    das Kommando <code>mapaddress</code> von der Controllerschnittstelle
    nutzt. Somit verschwenden wir nicht einen gesamten Round-trip
    innerhalb von Tor, um die Auflösung vor der Verbindung zu
    machen.</li>
    <li>Wir müssen unser <kbd>torify</kbd>-Skript so umgestalten, dass
    es erkennt, welches tsocks oder dsocks installiert ist und dieses
    dann richtig aufruft. Das bedeutet wahrscheinlich, dass deren
    Schnittstellen vereinheitlicht werden müssen und führt wahrscheinlich
    dazu, dass Code zwischen beiden geteilt werden muss oder dass eines
    komplett nicht mehr benutzt wird.</li>
  </ul></li>
  <li>Leute, die einen Server betreiben, teilen uns immer wieder mit,
    dass sie <var>BandwidthRate</var> in Abhängigkeit von der Uhrzeit setzen
    wollen. Anstatt das
    direkt in Tor zu implementieren, sollten wir lieber ein kleines
    Skript haben, das über die <a href="<page gui/index>">Torschnittstelle</a>
    spricht und ein <code>setconf</code> macht, um die Änderungen
    herbeizuführen. Natürlich würde es durch Cron ausgeführt oder es
    schläft eine bestimmte Zeit und macht dann die Änderungen. Kann
    das jemand für uns schreiben und wir packen das dann
    nach <a href="<svnsandbox>contrib/">contrib</a>? Das wäre
  eine gute Möglichkeit für den <a href="<page gui/index>">Tor GUI
  Wettbewerb</a>.</li>
  <li>Wir haben eine Vielzahl von Wegen, um
    das <a
    href="https://wiki.torproject.org/noreply/TheOnionRouter/TorFAQ#ChooseEntryExit">Tornetzwerk
    in einem bestimmten Land zu verlassen</a>. Aber all diese Wege
    brauchen den Namen eines speziellen Torservers. Es wäre schön,
    wenn man nur ein Land angeben muss und automatisch wird ein
    Server ausgewählt. Der beste Weg ist wahrscheinlich, Blossoms
  Verzeichnis herunterzuladen und einen lokalen Blossomclient laufen
  zu lassen, der die Verzeichnisse sicher lädt, die
  <code>.country.blossom</code>-Hostnamen mitschneidet und dann das
  richtige tut.</li>
  <li>Wenn wir gerade bei Geolocation sind, wäre es schön, wenn
    jemand eine Karte anfertigt, die die Standorte der Torserver
    anzeigt. Bonuspunkte gibt es, wenn es sich bei Änderungen am
    Netzwerk auf den neuesten Stand bringt. Der leichteste Weg, um
  dies zu erreichen, wäre alle Daten zu Google zu schicken und diese
  machen dann die Karte für uns. Wie sehr beeinflusst dies die
  Privatsphäre und haben wir noch andere gute Optionen?</li>
  <li>Tor bietet anonyme Verbindungen. Wenn du jedoch verschiedene
    Pseudonyme haben möchtest (z.B. rufst du desöfteren zwei Webseiten
    auf und wenn das jemand weiß, kann er auf dich schliessen.),
    unterstützen wir das nicht sehr gut.  Wir sollten einen guten
    Ansatz und eine Schnittstelle zur Handhabung von pseudonymen
    Profilen finden. Schaue dir
    den <a
    href="http://archives.seul.org/or/talk/Dec-2004/msg00086.html">Beitrag
    </a> und den <a
    href="http://archives.seul.org/or/talk/Jan-2005/msg00007.html">Followup</a>
    für mehr Details an.</li>
</ol>

<a id="Documentation"></a>
<h2><a class="anchor" href="#Documentation">Dokumentation</a></h2>

<ol>
  <li>Bitte hilf Matt Edman mit der Dokumentation und HOWTOs für
  seinen <a href="http://vidalia-project.net/">Vidalia</a>.</li>
  <li>Kommentiere und dokumentiere unsere <a
    href="https://wiki.torproject.org/wiki/TheOnionRouter/TorifyHOWTO">Liste
    von Programmen, die durch Tor geroutet werden können</a>.</li>
  <li>Wir brauchen bessere Dokumentation für Programme, die dynamisch
    in Verbindungen eingreifen und diese durch Tor schicken. Für Linux
    und Windows scheinen tsocks (Linux), dsocks (BSD), und freecap gute Kandidaten.</li>
  <li>Wir haben eine riesige
    Liste <a href="<page support>">potentiell nützlicher Programme,
    die eine Schnittstelle zu Tor haben</a>. Welche sind in welchen
    Situationen gut? Bitte hilf uns, diese zu testen und dokumentiere
    die Ergebnisse.</li>
  <li>Hilf, die Webseite und die Dokumentation in andere Sprachen zu
  übersetzen. Schaue dir die <a href="<page translation>">Richtlinien
  zur Übersetzung</a> an, wenn du gern helfen möchtest. Wir brauchen
  auch Leute, um die Seiten in Arabisch oder Farsi zu übersetzen. Einen
  Überblick gibt
  es bei der <a href="<page translation-status>">Statusseite der
  Übersetzungen</a>.</li>
  </ol>

<a id="Coding"></a>
<h2><a class="anchor" href="#Coding">Programmierung und Design</a></h2>

<ol>
  <li>Torserver funktionieren unter Windows XP nicht sehr gut. Wir
  verwenden auf Windows den standardmäßigen <code>select</code>-Systemaufruf.
  Dies bereitet gerade auf mittelgroßen Servern <a
  href="https://wiki.torproject.org/noreply/TheOnionRouter/WindowsBufferProblems">Probleme</a>.
  Wahrscheinlich sollten wir hier besser Overlapped I/O nutzen. Eine Lösung
  wäre, <a href="http://www.monkey.org/~provos/libevent/">libevent</a>
  beizubringen, Overlapped I/O statt <code>select()</code> zu wählen. Tor muss
  dann an die neue libevent-Schnittstelle angepasst werden. Christian King hat
  <a href="https://tor-svn.freehaven.net/svn/libevent-urz/trunk/">einen guten
  Anfang</a> gemacht.</li>
  <li>Wie können wir die <a
  href="http://anonymityanywhere.com/incognito/">Incognito LiveCD</a> leichter
  zu warten, verbessern und zu dokumentieren machen?</li>
  <li>Wir brauchen ein verteiltes Testgerüst. Bisher haben wir Unittests. Es
  wäre großartig, ein Skript zu haben, welches ein Tornetzwerk startet und dort
  für einige Zeit testet, ob die Erneuerungen funktionieren.</li>
  <li>Hilf Mike Perry bei der <a
r href="https://www.torproject.org/svn/torflow/">TorFlow</a>-Bibliothek (<a
  href="https://www.torproject.org/svn/torflow/TODO">TODO</a>). Es ist eine
  Pythonbibliothek, die das <a
  href="https://www.torproject.org/svn/torctl/doc/howto.txt">Tor Controller Protokoll
  </a> nutzt, um mit Tor eine Vielzahl von Verbindungen zu schaffen, diese zu
  messen und Anomalien festzustellen.</li>
  <li>Wir sollten damit anfangen unser <a href="<page
  documentation>#DesignDoc">gegen Blockierungen geschütztes Design</a> zu
  implementieren. Dies beinhaltet die Ausarbeitung des Designs, die
  Modifizierung diverser Teile von Tor, die Arbeit an einer <a
  href="http://vidalia-project.net/">GUI</a>, die intuitiv ist und die Planung
  für den Einsatz.</li>
  <li>Wir brauchen ein flexibles Gerüst, um Ende-zu-Ende Attacken des
  Netzverkehrs zu simulieren. Viele Forscher haben Simulatoren geschaffen, die
  ihre Intuition, ob ein Angriff oder Verteidigung funktioniert, unterstützt.
  Können wir einen Simulator bauen, der offen und gut dokumentiert ist? Dies
  wird eine Menge neuer Forschung anregen. Schaue auch auf den <a
  href="#Research">Eintrag unten</a>, um Details zu dieser Aufgabe zu entdecken.
  Wenn es fertig ist, könntest du helfen, eine Veröffentlichung  dazu zu schreiben.</li>
  <li>Momentan werden die Deskriptoren der versteckten Services nur
  auf einigen wenigen Verzeichnisservern gespeichert. Dies ist
  schlecht für die Privatsphäre und die Robustheit. Um mehr Robustheit
  zu erlangen, sollten wir die privaten Daten aus den Deskriptoren
  entfernen, um diese auf verschiedenen Plätzen spiegeln zu
  können. Idealerweise hätten wir gern ein Speicher-/Backupsystem, das
  verschieden zu den Verzeichnisservern ist. Das erste Problem ist,
  das wir Format für die versteckten Services schaffen müssen, welches
  a) ASCII statt binär ist, b) die Liste der Introductionpoints
  verschlüsselt, solange man nicht die <tt>.onion</tt>-Adresse kennt
  und c) den Verzeichnissen erlaubt, den Zeitstempel und die Signatur
  eines Deskriptors zu verifizieren, so dass diese nicht mit falschen
  überrumpelt werden. Zweitens wird es jedes verteilte Speichersystem
  tun, solange es authentifizierte Updates erlaubt.</li>
  <li>Torversionen ab 0.1.1.x unterstützen Cryptohardwarebeschleuniger
    via OpenSSL. Bisher hat das niemand getestet. Möchte jemand gern
    eine Karte haben und schauen, ob das funktioniert?</li>
  <li>Eine Sicherheitsanalyse mit
    "<a href="http://en.wikipedia.org/wiki/Fuzz_testing">Fuzz</a>"
    machen.  Herausfinden, ob es da draußen gute Bibliotheken dafür
    gibt. Gewinne Ruhm und Ehre, wenn wir nur wegen dir ein neues
    Release herausbringen!</li>
  <li>Tor nutzt TCP für den Transport und TLS für die Verschlüsselung
    der Verbindungen. Dies ist einfach. Es bedeutet aber auch, dass
    alle Zellen Verspätungen erfahren, wenn nur ein Paket verworfen
    wird. Daher können wir nur bedingt TCP-Streams unterstützen. Es
    gibt eine <a
    href="https://wiki.torproject.org/noreply/TheOnionRouter/TorFAQ#TransportIPnotTCP">Liste
    von Gründen</a>, warum wir nicht zu Transport per UDP gewechselt
    sind. Es wäre schön, wenn diese Liste kürzer werden würde. Wir
  haben auch eine <a
  href="<svnsandbox>doc/100-tor-spec-udp.txt">Spezifikation für Tor
  und UDP</a> &mdash; bitte lass uns wissen, wenn damit etwas nicht
  stimmt.</li>
  <li>Wir sind nicht weit davon entfernt, Unterstützung für IPv6 bei
    Exitknoten zu haben. Falls du dich stark um IPv6 kümmerst, ist
    das wahrscheinlich der Platz, um zu starten.</li>
  <li>Du magst keinen von den obigen Punkten? Schaue dir die <a
  href="<svnsandbox>doc/design-paper/roadmap-future.pdf">weiteren Pläne</a> für
  weitere Ideen an.</li>
</ol>

<a id="Research"></a>
<h2><a class="anchor" href="#Research">Forschung</a></h2>

<ol>
  <li>Die Fingerprintattacken gegen Webseiten machen eine Liste von
    einigen wenigen populären Webseiten, laden die Inhalte herunter
    und machen einen Satz von Signaturen für jede Seite. Danach
    beobachten sie den Verkehr des Torclients. Währenddessen gelangen sie
    schnell zu einer Vermutung, welche Seite gerade besucht wird. Wie
    effektiv ist dieser Angriff bezüglich der aktuellen Codebasis von
    Tor? Beginne danach Verteidigungsmöglichkeiten auszuloten. Wir
    könnten beispielsweise die Zellgröße von 512 Bytes auf 1024 Bytes
    anheben und Techniken wie <a
    href="http://freehaven.net/anonbib/#timing-fc2004">defensives
    Verwerfen</a> anwenden. Wir könnten auch künstliche Verspätungen
    einarbeiten. Welchen Einfluss haben diese Massnahmen und wie groß
    ist der Einfluss auf die Benutzbarkeit?</li>
  <li>Eine weitere Angriffsmöglichkeit (end-to-end traffic
    confirmation attack) basiert darauf, dass der Verkehr zwischen
    Alice und Bob beobachtet wird. Durch den <a
    href="http://freehaven.net/anonbib/#danezis:pet2004">Vergleich
    der Signaturen des Netzverkehrs kann man herausfinden, on man
    denselben Stream verfolgt</a>. Bis jetzt akzeptiert Tor dies als
    Fakt und nimmt an, dass dies in allen Fällen trivial ist. Ist das
    wahr? Wieviel Verkehr von welcher Sorte braucht man, um sicher zu
    sicher, dass es funktioniert? Gibt es Szenarien, die die Attacke
    ausbremsen? Funktioniert Padding besser als anderes?</li>
  <li>Die Attacke auf die Routingzonen ist der Netzpfad zwischen
    Alice und dem Eingangsknoten (bzw. zwischen dem Exitknoten und
    Bob). In der Literatur wird dies als einfache Verbindung auf
    einem Graph dargestellt. In der Praxis durchquert der Pfad viele
    autonome Systeme. Es ist nicht ungewöhnlich, dass dasselbe
    <a href="http://freehaven.net/anonbib/#feamster:wpes2004">autonome
    System sowohl beim Eingangs- wie auch beim Ausgangspfad
    erscheint</a>. Um nun herauszufinden, ob ein spezielles Alice-,
    Eingangs-, Ausgangs-, Bobviereck gefährlich ist, müssten wir die
    gesamte Routingzone des Internet herunterladen und Operationen
    darauf ausführen. Gibt es praktische Abschätzungen, die die
    Arbeit erleichtern können?</li>
    <li>Andere Fragen in der Forschung, die die geografische
    Verteilung betreffen, betrachten einen Kompromiss zwischen der Wahl
    einer effizienten Route und einer zufälligen Route. Wirf einen Blick
    auf das <a
    href="http://swiki.cc.gatech.edu:8080/ugResearch/uploads/7/ImprovingTor.pdf">Positionspapier</a>
    von Stephen Rollyson. Es diskutiert, wie man langsame Leitungen
    auschalten kann, ohne die Anonymität zu stark einzuschränken. Die
    Begründungen machen einen guten Eindruck, brauchen aber noch mehr
    Arbeit.</li>
  <li>Tor funktioniert nicht sehr gut, wenn Server eine asymmetrische
    Bandbreite (Kabel oder DSL) haben. Tor hat separate
    TCP-Verbindungen zwischen jedem Hop. Wenn nun die einkommenden
    Pakete gut ankommen und die ausgehenden alle verworfen werden,
    übertragen die die TCP-Pushback-Mechanismen diese Informationen
    nicht gut hin zu den eingehenden Verbindungen. Eventuell sollte
    Tor feststellen, wenn eine Menge an ausgehenden Verbindungen
    verworfen werden und dann die eigehenden Verbindungen selbst
    herunterregeln? Ich könnte mir ein Schema vorstellen, wo wir ein
    konservatives Ratelimit suchen und das langsam vergrößern, bis
    Pakete verworfen werden. Wir brauchen jemanden, der sich gut mit
    Netzwerken auskennt, um dies zu simulieren und eine Lösung zu
    finden. Wir müssen die Erosion in der Performance verstehen und
    das als Motivation für Transport per UDP verstehen.</li>
  <li>Ein verwandtes Thema ist die Kontrolle bei Netzüberlastung. Ist
    unser Design ausreichend, um hohe Netzlast auszuhalten?
    Vielleicht sollten wir mit Fenstern von variabler Größe
    experimentieren? Das schien im <a
    href="http://www.psc.edu/networking/projects/hpn-ssh/theory.php">Experiment
    mit dem SSH-Durchsatz</a> gut zu funktionieren. Wir müssen das
    messen und verbessern und bei guten Resultaten Tor überholen.</li>
  <li>Damit Dissidenden in fernen Ländern Tor nutzen können, ohne von
    der Firewall des Landes geblockt zu werden, brauchen wir einen
    Weg, um zehntausende von Relays zu bekommen anstatt nur einigen
    hundert. Wir können uns eine GUI vorstellen, die einen "Tor for
    Freedom"-Button (Tor für die Freiheit) hat. Dieser öffnet einen
    Port und verteilt ein paar
    Kilobyte Traffic ins Tornetzwerk. Wie verteilen wir eine Liste
    dieser Freiwilligen in einer automatischen Art und Weise? Dies
    muss so passieren, dass die Firewalls auf Landesebene diese nicht
    erkennen. Wahrscheinlich muss das auf einem Niveau persönlichen
    Vertrauens funktionieren. Siehe unseren <a href="<page
  documentation>#DesignDoc">Designdokument hierzu</a> sowie den <a
    href="https://wiki.torproject.org/noreply/TheOnionRouter/TorFAQ#BlockingResistance"
    >Eintrag in der FAQ</a> und lies dann <a
    href="http://freehaven.net/anonbib/topic.html#Communications_20Censorship"
    >die Zensurwiderstandssektion der AnonBib</a>.
    </li>
  <li>Tor-Verbindungen werden schrittweise aufgebaut, ein Knoten nach
    dem anderen.  Also haben wir theoretisch die Möglichkeit, manche
    Ströme schon nach dem zweiten Knoten die Tor-Wolke verlassen zu
    lassen, andere nach dem dritten Knoten, und so weiter.  Dies erscheint
    nett, weil es die Menge der austretenden Ströme, welcher ein bestimmter
    Server sieht, begrenzt.  Wenn wir diesen Strom jedoch sicher haben wollen,
    dann, laut unserer aktuellen Logik,  sollte der kürzeste Pfad mindestens 3
    Knoten lang sein.  Das heisst, die anderen Ströme wären noch länger.  Wir
    müssen diese Performance/Sicherheitsabwägung untersuchen.</li>
   <li>Es ist nicht schwer, DoS Angriffe auf Tor-Server oder
    Tor-Verzeischnisserver erfolgreich durchzuführen.  Sind Client-Puzzles die
    richtige Anwort?  Welche anderen praktischen Herangehensweisen gibt es?
    Bonuspunkte, wenn diese mit dem aktuellen Tor-Protokoll abwärtskompatibel
    sind.</li>
  </ol>

<p><a href="<page contact>">Lass uns wissen</a>, wenn du bei einem
  dieser Punkte Fortschritte gemacht hast.</p>

</div><!-- #main -->

#include <foot.wmi>

## translation metadata
# Based-On-Revision: 13843
# Last-Translator: bogdandr_at_op . pl

#include "head.wmi" TITLE="Tor: Wolontariusze" CHARSET="UTF-8"

<div class="main-column">

<!-- PUT CONTENT AFTER THIS TAG -->
<h2>Trzy rzeczy, które każdy może zrobić już teraz:</h2>
<ol>
<li>Prosimy rozważyć <a href="<page docs/tor-doc-relay>">uruchomienie
 przekaźnika sieci Tor</a>, by wspomóc rozwój sieci Tora.</li>
<li>Rozpowiadaj o systemie Tor swoim znajomym. Spraw, by uruchomili przekaźniki sieci.
 Spraw, by uruchomili usługi ukryte. Spraw, by mówili o systemie Tor swoim znajomym.</li>
<li>Szukamy funduszy i sponsorów. Jeśli podobają ci się cele Tora,
  <a href="<page donate>">poświęć chwilę, by złożyć dotację, aby wspomóc przyszły rozwój Tora</a>.
  Jeśli znasz jakieś firmy, organizacje pozarządowe, agencje lub inne organizacje, które
  są zainteresowane bezpieczną komunikacją, daj im znać o nas.</li>
</ol>

<a id="Usability"></a>
<h2><a class="anchor" href="#Usability">Aplikacje Wspomagające</a></h2>
<ol>
 <li>Potrzebujemy dobrych sposobów na przechwytywanie żądań DNS, żeby nie
 "przeciekały" do lokalnych obserwatorów, podczas gdy chcemy zachować anonimowość.
 (Dzieje się tak, gdyż aplikacja wysyła żądanie DNS przed przejściem przez serwer
 Proxy SOCKS.)</li>
<li>Sprawy z Tsocks/dsocks:
 <ul>
<li>Musimy <a
 href="https://wiki.torproject.org/noreply/TheOnionRouter/TSocksPatches">zastosować
 nasze wszystkie łaty tsocks do kodu</a> i utrzymywać nową gałąź. Możemy ją hostować, jeśli chcesz.</li>
<li>Powinniśmy załatać program "dsocks" Duga Songa, by używał komend
 <i>mapaddress</i> Tora z interfejsu kontroli, żeby nie marnować przejścia
 całej trasy w Torze, wykonując rozwiązywanie adresów przed połączeniem.</li>
<li>Musimy sprawić, by nasz skrypt <i>torify</i> wykrywał, który z programów
 tsocks lub dsocks jest zainstalowany, i odpowiednio je uruchamiał. To
 prawdopodobnie oznacza zunifikowanie ich interfejsów i w grę może wchodzić
 dzielenie kodu między nimi lub całkowita rezygnacja z jednego z nich.</li>
</ul>
</li>
<li>Ludzie, którzy uruchomili przekaźnik sieci Tora mówią nam, że chcą dać jedną
 przepustowość łącza dla Tora (BandwidthRate) w czasie pewnej części dnia,
 a inną w innych częściach dnia. Zamiast programować to w Torze, powinniśmy mieć
 mały skrypt, który łączy się przez <a href="<page gui/index>">Tor Controller Interface</a>,
 i wykonuje SETCONF by zmienić przepustowość. Jest już po jednym skrypcie dla systemów
 Unix i Mac (korzystają z basha i crona), ale dalej potrzebne jest rozwiązanie
 dla użytkowników Windowsa.
 </li>
<li>Tor może <a
 href="https://wiki.torproject.org/noreply/TheOnionRouter/TorFAQ#ChooseEntryExit">wychodzić
 z sieci Tora używając podanego węzła</a>, ale powinniśmy móc podać tylko kraj i mieć coś,
 co automatycznie za nas wybierze węzeł. Najlepszym kandydatem jest pobranie także
 katalogu Blossom i uruchomienie lokalnego klienta Blossom, który pobrałby swój katalog w
 sposób bezpieczny (poprzez Tor i sprawdzając jego podpis), przechwycałby nazwy
 hostów <tt>.country.blossom</tt>  i robił to, co trzeba.</li>
<li>A mówiąc o danych geolokacyjnych, ktoś powinien narysować mapę Ziemi z
 zaznaczonym każdym przekaźnikiem sieci Tora. Dodatkowe punkty, jeśli mapa będzie się
 aktualizować w miarę jak sieć rośnie i się zmienia. Niestety, łatwy sposób na
 dokonanie tego to wysłanie wszystkich danych do Google, w celu narysowania
 przez nich taj mapy. Jak bardzo to uderza w prywatność i czy mamy jakieś inne
 dobre wyjścia?</li>
</ol>

<a id="Documentation"></a>
<h2><a class="anchor" href="#Documentation">Dokumentacja</a></h2>
<ol>
<li>Proszę pomóc Mattowi Edmanowi z dokumentacją i dokumentami jak-to-zrobić do
 jego projektu Tor Controller i <a href="http://vidalia-project.net/">Vidalia</a>.</li>
<li>Przejrzyj i udokumentuj
 <a href="https://wiki.torproject.org/wiki/TheOnionRouter/TorifyHOWTO">naszą
 listę programów</a>, które można skonfigurować do współpracy z Torem.</li>
<li>Potrzebujemy lepszej dokumentacji do dynamicznego przechwytywania połączeń
 i wysyłania ich przez Tora. tsocks (Linux), dsocks (BSD),
 i freecap (Windows) zdają się być dobrymi kandydatami, jako że lepiej
 używałyby naszej nowej cechy TransPort.</li>
<li>Mamy ogromną listę <a
 href="https://wiki.torproject.org/noreply/TheOnionRouter/SupportPrograms">potencjalnie
 użytecznych programów, które współpracują z Torem</a>. Które z nich są
 przydatne w jakich sytuacjach? Proszę pomóż nam je testować i zapisuj
 swoje wyniki.</li>
<li>Pomóż przetłumaczyć stronę WWW i dokumentację na inne języki. Spójrz na
 <a href="<page translation>">wskazówki do
 tłumaczenia</a>, jeśli chcesz pomóc. Potrzebujemy zwłaszcza tłumaczy na język
 arabski i Farsi dla wielu użytkowników Tora w cenzorowanych obszarach.</li>

</ol>

<a id="Coding"></a>
<h2><a class="anchor" href="#Coding">Programowanie i Projektowanie</a></h2>

<ol>

<li>Przekaźniki sieci Tora nie działają zbyt dobrze na Windows XP. Pod systemem Windows Tor
 używa standardowej funkcji systemowej <tt>select()</tt>, która zużywa miejsce
 w niestronicowanym obszarze pamięci. Znaczy to, że średnich rozmiarów
 przekaźnik sieci Tora zapełni dotępną przestrzeń, <a
 href="https://wiki.torproject.org/noreply/TheOnionRouter/WindowsBufferProblems">będąc
 przyczyną dziwnych zachowań i padów systemu</a>. Powinniśmy raczej używać
 nakładającego IO. Jednym z rozwiązań byłoby nauczenie biblioteki <a
 href="http://www.monkey.org/~provos/libevent/">libevent</a>, jak używać nakładającego IO
 zamiast select() pod Windows, po czym zaadaptować Tora do nowego interfejsu.
 Christian King zrobił
 <a href="https://tor-svn.freehaven.net/svn/libevent-urz/trunk/">pierwszy dobry
 krok</a> zeszłego lata.</li>

<li>Jak można uczynić <a
href="http://anonymityanywhere.com/incognito/">Incognito LiveCD</a>
łatwiejszym w utrzymaniu, ulepszaniu i dokumentowaniu?</li>

<li>Ponieważ przekaźniki sieci Tora muszą przechować i podać dalej każdą komórkę,
 którą obsługują, przekaźniki o wysokiej przepustowości zużywają wiele
 megabajtów pamięci na same bufory. Potrzebujemy lepszej heurystyki do
 określenia, kiedy skurczyć/rozszerzyć bufory. Może to powinno być zaprojektowane
 podobnie jak bufory w jądrze Linuksa, gdzie jest wiele mniejszych buforów, które
 łączą się wzajemnie, zamiast używać monolitycznych buforów?</li>

<li>Potrzebujemy oficjalnej, centralnej strony, która odpowiadałaby na pytania
 "Czy to jest adres przekaźnika wyjściowego z sieci Tor?". Strona powinna dostarczyć klika
 interfejsów, łącznie z interfejsem www i w stylu DNSBL. Powinna dostarczać najbardziej
 aktualne odpowiedzi, przechowując lokalną kopię katalogów. Haczyk jest w tym, że
 bycie przekaźnikiem wyjściowym nie jest takie proste jak tylko prawda czy fałsz,
 więc pytanie powinno raczej
 brzmieć: "Czy to jest adres przekaźnika wyjściowego z sieci Tor, z którego można się
 połączyć z moim adresem IP i portem?". Interfejs DNSBL będzie pewnie otrzymywał
 setki zapytań na minutę, potrzeba więc mądrych algorytmów. Dodatkowe punkty, jeśli
 aktywnie byłoby sprawdzane każdego węzła wyjściowego, z jakiego adresu IP naprawdę
 wychodzą dane. <a href="<svnsandbox>doc/contrib/torel-design.txt">Czytaj więcej tu</a>.</li>

<li>Czasami przekaźniki sieci Tora padają, komputery z tymi serwerami zostają odłączone od sieci
 lub zdarzają się inne wypadki. Część operatorów Tora wyraziła zainteresowanie zapisaniem
 się do usługi "powiadamiającej", która okresowo sprawdzałaby, czy ich przekaźnik działa, i
 wysyłała list przypominający, gdy serwer nie działa. Czy ktoś chce napisać kilka skryptów
 CGI, kilka stron internetowych i używać jakiegoś sposobu z Wget lub czegoś bardziej
 złożonego jak <a href="http://nagios.org/">Nagios</a> do monitorowania? Pierwsza wersja
 mogłaby po prostu sprawdzać port w katalogu, np. przeglądając zapisaną stronę ze
 stanem sieci w poszukiwaniu właściwego adresu IP i portu, po czym żądając strony
 "/tor/server/authority".</li>

<li>Byłoby wspaniale mieć LiveCD zawierające najnowsze wersje Tor, Polipo lub Privoxy,
 Firefox, Gaim+OTR itp. Są tu dwa wyzwania: pierwszym jest udokumentowanie systemu i
 możliwości wyboru dość dobrze, by ludzie zajmujący się bezpieczeństwem mogli wydać opinię
 o tym, czy taki system byłby bezpieczny, a drugim wyzwaniem jest jak sprawić, by taki
 system był łatwy w utrzymaniu, żeby nie ulegał szybkim przedawnieniom, jak AnonymOS.
 Dodatkowe punkty, jeśli obraz CD zmieści się na małej płycie.</li>

<li>W połączeniu z obrazem LiveCD, powinniśmy popracować nad intuicyjnie bezpiecznym
 i dobrze udokumentowanym obrazem USB dla Tora i aplikacji obsługujących. Ciężką
 częścią tutaj jest zdecydowanie, jakie konfiguracje są bezpieczne, dokumentowanie
 tych decyzji i zrobienie czegoś, co łatwo będzie utrzymać w przyszłości.</li>

<li>Nasz preferowany interfejs graficzny dla Tora, o nazwie
 <a href="http://vidalia-project.net/">Vidalia</a>, potrzebuje różnego rodzaju pracy włożonej
 w rozwój.</li>

<li>Musimy zacząć budować nasz <a href="<page
 documentation>#DesignDoc">projekt odporny na blokowanie</a>. Wchodzi w to
 przemyślenie projektu, zmiana wielu różnych elementów Tora, zaadaptowanie
 <a href="http://vidalia-project.net/">Vidalii</a>, by obsługiwała nowe cechy i
 planowanie rozpowszechniania.</li>

<li>Potrzebujemy elastycznego frameworka symulacji do badania ataków potwierdzenia
 ruchu od nadawcy do odbiorcy (end-to-end). Wielu ludzi szybko wyciągnęło/napisało doraźne
 symulatory odpowiadające ich intuicji, że albo ataki znakomicie się udają, albo
 że obrona działa dobrze. Czy możemy zbudować symulator, który jest dobrze udokumentowany
 i dość otwarty, by wszyscy wiedzieli, że daje rozsądną odpowiedź? To zacznie wiele nowych
 badań. Spójrz na wpis <a href="#Research">poniżej</a> o atakach potwierdzenia po szczegóły
 strony badawczej tego zadania &mdash; kto wie, może gdy będzie skończone, pomożesz nam też
 napisać dokumentację.</li>

<li>Potrzebujemy frameworka do testów rozproszonych. Mamy pojedyncze testy, ale byłoby
 wspaniale mieć skrypt, który uruchamia sieć Tora, używa jej przez chwilę i weryfikuje,
 że przynajmniej jej część działa.</li>

<li>Pomóżcie Mike'owi Perry z jego biblioteką <a
 href="https://www.torproject.org/svn/torflow/">TorFlow</a>
 (<a href="https://www.torproject.org/svn/torflow/TODO">lista rzeczy do zrobienia</a>):
 jest to biblioteka napisana w Pythonie, która używa <a
 href="https://www.torproject.org/svn/torctl/doc/howto.txt">protokołu kontroli Tora</a>,
 by instruować Tora do budowania obwodów na wiele różnych sposobów, po czym
 mierzy wydajność i próbuje wykryć anomalie.</li>

<li>Tor 0.1.1.x i późniejsze zawiera obsługę sprzętowych akceleratorów kryptograficznych,
 poprzez OpenSSL. Ale nikt tego jeszcze nie przetestował. Czy ktoś chce
 zdobyć kartę i powiadomić nas, jak to działa?</li>
<li>Dokonać analizy bezpieczeństwa Tora z <a
 href="http://en.wikipedia.org/wiki/Fuzz_testing">"fuzz"</a>. Sprawdzić, czy
 istnieją jakieś dobre biblioteki "fuzz", których nam potrzeba. Zdobądź sławę
 gdy wydamy nową wersję dzięki Tobie!</li>
<li>Tor używa TCP do transportu i TLS do szyfrowania transmisji. To jest
 ładne i proste, ale oznacza to, że wszystkie komórki na łączu zostają
 opóźnione, gdy pojedynczy pakiet zostanie utracony, co oznacza, że rozsądnie
 obsługiwać możemy tylko strumienie TCP. Mamy <a
 href="https://wiki.torproject.org/noreply/TheOnionRouter/TorFAQ#TransportIPnotTCP">listę
 powodów, dla których nie przenieśliśmy się na UDP</a>, ale byłoby dobrze
 skrócić tę listę. Mamy też proponowaną <a
 href="<svnsandbox>doc/spec/proposals/100-tor-spec-udp.txt">specyfikację dla Tora i
 UDP</a> &mdash; proszę dać znać, co z nią jest nie tak.</li>
<li>Jesteśmy wcale niedaleko od obsługi adresów IPv6 jako docelowych (na węzłach
 wyjściowych). Jeśli mocno ci zależy na IPv6, to jest to chyba najlepszy punkt
 startu.</li>
<li>Nie podoba ci się żaden z tych pomysłów? Spójrz na <a
 href="<svnsandbox>doc/design-paper/roadmap-future.pdf">plan rozwoju Tora</a> po więcej pomysłów.</li>
<li>Nie widzisz tu swojego pomysłu? Prawdopodobnie i tak go potrzebujemy! Skontaktuj się
 z nami, by to sprawdzić.</li>
</ol>

<a id="Research"></a>
<h2><a class="anchor" href="#Research">Badania</a></h2>
<ol>
<li>"Atak na odciski palców stron WWW" (website fingerprinting attack): sporządź listę kilkuset
 popularnych stron WWW, ściągnij ich strony i zrób listę "podpisów"
 dla każdej z nich. Potem obserwuj ruch sieciowy klienta Tora. Jak
 patrzysz na odbierane przez niego dane, szybko zgadujesz, którą
 (jeśli w ogóle) on odbiera. Po pierwsze, jak bardzo ten atak jest
 efektywny? Potem zacznij badać sposoby obrony: na przykład, moglibyśmy
 zmienić rozmiar komórki Tora z 512 na 1024 bajty, moglibyśmy użyć
 technik dopełniających, jak <a
 href="http://freehaven.net/anonbib/#timing-fc2004">odrzucanie obronne (defensive dropping)</a>,
 lub moglibyśmy dodać opóźnienia w ruchu. Jak wielki wpływ mają te
 rozwiązania i jak wielki wpływ na używalność (używając odpowiedniego
 sposobu mierzenia) ma udana obrona w każdym z przypadków?
</li>
<li>"Atak potwierdzenia w ruchu nadawca-odbiorca" (end-to-end traffic confirmation attack):
 obserwując ruch od Alicji do Boba, możemy <a
 href="http://freehaven.net/anonbib/#danezis:pet2004">porównać
 sygnatury ruchu i przekonać się, że obserwujemy ciągle ten sam strumień danych</a>.
 Jak na razie, Tor przyjmuje to jako pewnik i zakłada, że ten atak jest
 trywialny we wszystkich przypadkach. Po pierwsze, czy tak rzeczywiście jest?
 Jak wiele ruchu/danych o jakim rozkładzie jest potrzebne, by przeciwnik
 upewnił się, że wygrał? Czy są jakieś sytuacje (np. nie wysyłanie wiele danych),
 które spowolniłyby atak? Czy jakieś dopełnienia transmisji lub inne sposoby
 kształtowania działają lepiej od innych?
 </li>
<li>"Atak stref trasowania" (routing zones attack): większość literatury
 mówi o ścieżce sieciowej między Alicją a jej węzłem wejściowym (i między
 węzłem wyjściowym a Bobem) jako o pojedynczej ścieżce na jakimś grafie.
 W rzeczywistości, ścieżka przemierza wiele systemów autonomicznych (SA), i <a
 href="http://freehaven.net/anonbib/#feamster:wpes2004">często zdarza się, że
 ten sam SA pojawia się zarówno na ścieżce wejściowej i wyjściowej</a>.
 Niestety, by dokładnie przewidzieć, czy podany czworobok
 Alicja-wejście-wyjście-Bob jest niebezpieczny, musielibyśmy ściągnąć
 całą strefę trasowania internetu i dokonać na niej czasochłonnych operacji.
 Czy są jakieś praktyczne aproksymacje, jak np. unikanie adresów IP z tej
 samej sieci /8?
 </li>
<li>Inne pytania badawcze dotyczące różnorodności geograficznej rozpatrują
 kompromis między wybieraniem obwodu wydajnego a losowego. Spójrz na <a
 href="http://swiki.cc.gatech.edu:8080/ugResearch/uploads/7/ImprovingTor.pdf">dokument o
 pozycjach</a> Stephena Rollysona na temat tego, jak odrzucać szczególnie wolne
 możliwości bez zbytniej utraty anonimowości. Ta argumentacja wymaga więcej pracy i
 myślenia, ale wygląda bardzo obiecująco.</li>

<li>Tor nie działa za dobrze, gdy przekaźnik sieci ma asymetryczne łącze
 (np. kablówka czy DSL). Ponieważ Tor wykonuje oddzielne połączenia między
 każdym skokiem, jeśli przychodzące bajty są przysyłane dobrze, a wychodzące
 są wyrzucane, mechanizmy push-back w TCP nie transmitują tej informacji
 z powrotem do strumienia przychodzącego. Być może Tor powinien odkryć, gdy
 wyrzuca dużo pakietów wychodzących, i ograniczyć strumienie przychodzące,
 by sam tym regulować? Można sobie wyobrazić schemat działania, w którym
 najpierw wybieramy niski limit przepustowości, powoli go zwiększając aż do
 chwili w której zaczęlibyśmy tracić pakiety - wtedy nastąpiłoby cofnięcie się.
 Potrzebujemy kogoś dobrze znającego sieci by to zasymulował i pomógł
 zaprojektować rozwiązania; musimy zrozumieć stopień degradacji wydajności i
 użyć tego argumentu jako motywacji do ponownego rozpatrzenia transportu UDP.
 </li>
<li>Powiązanym tematem jest kontrola zatorów. Czy nasz dotychczasowy projekt
 okaże się wystarczający, gdy będziemy mieli duży ruch? Może powinniśmy
 poeksperymentować z oknami o zmiennym rozmiarze zamiast z oknami o stałym?
 To zdawało się działać nieźle w <a
 href="http://www.psc.edu/networking/projects/hpn-ssh/theory.php">eksperymencie
 przepustowości SSH</a>. Będziemy musieli mierzyć i podkręcać, i być może
 wykonać poprawki, jeśli wyniki okażą się dobre.
 </li>
<li>Aby umożliwić dysydentom w innych krajach używanie Tora bez bycia
 zablokowanym przez zaporę ogniową w ich kraju, potrzebujemy sposobu na
 zdobycie dziesiątek tysięcy serwerów pośredniczących, nie zaledwie kilkuset.
 Wyobrażamy sobie GUI klienta Tora, które na górze ma przycisk "Tor dla wolności",
 który otwiera port i przekierowuje kilka kB/s ruchu do sieci Tor. (Kilka kB/s
 nie powinno być dużym kłopotem i nie będzie wiele spraw o nadużycia, gdyż
 nie będą to węzły wyjściowe.) Ale jak rozpowszechniać listę tych
 klientów-wolontariuszy do dobrych dysydentów automatycznie w taki sposób, który
 nie pozwoli krajowym zaporom ogniowym przechwycić i zliczyć ich? To prawdopodobnie
 musi działać poziomie zaufania ludzkiego. Spójrz na nasz
 <a href="<page documentation>#DesignDoc">wstępny dokument o
 ochronie przed blokowaniem</a> i na nasz <a
 href="https://wiki.torproject.org/noreply/TheOnionRouter/TorFAQ#BlockingResistance">wpis w FAQ</a>
 o tym, a potem przeczytaj <a
 href="http://freehaven.net/anonbib/topic.html#Communications_20Censorship">sekcję w anonbib o
 przeciwstawianiu się cenzurze</a>.</li>
<li>Obwody Tora są budowane po jednym elemencie na raz, więc teoretycznie
 możemy uczynić, aby część strumieni wychodziła z drugiego węzła, część z
 trzeciego itd. To wydaje się dobre, bo ogranicza zbiór strumieni wychodzących,
 które dany przekaźnik sieci może zobaczyć. Ale jeśli chcemy by każdy strumień był
 bezpieczny, "najkrótsza" ścieżka powinna, według naszego bieżącego rozumowania,
 składać się z co najmniej 3 elementów, więc inne będą jeszcze dłuższe.
 Musimy zbadać ten kompromis wydajność/bezpieczeństwo.
 </li>
<li>Nie jest trudno wykonać atak DoS na przekaźniki sieci Tora lub centra katalogowe.
 Zagadki dla klientów (?) (client puzzles) są właściwą odpowiedzią? Jakie są
 inne praktyczne podejścia? Dodatkowe punkty, jeśli są zgodne wstecz z
 bieżącym protokołem Tora.</li>
</ol>

<a href="<page contact>">Daj nam znać</a>, jeśli poczyniłeś postępy nad którąkolwiek z tych rzeczy!

  </div><!-- #main -->

#include <foot.wmi>


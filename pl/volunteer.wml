## translation metadata
# Based-On-Revision: 18710
# Translation-Priority: 4-optional
# Last-Translator: bogdandr_at_op . pl

#include "head.wmi" TITLE="Tor: Wolontariusze" CHARSET="UTF-8"

<div class="main-column">

<!-- PUT CONTENT AFTER THIS TAG -->
<h2>Kilka rzeczy, które każdy może zrobić już teraz:</h2>
<ol>
<li>Prosimy rozważyć <a href="<page docs/tor-doc-relay>">uruchomienie
 przekaźnika sieci Tor</a>, by wspomóc rozwój sieci Tora.</li>
<li>Rozpowiadaj o systemie Tor swoim znajomym. Spraw, by uruchomili przekaźniki sieci.
 Spraw, by uruchomili usługi ukryte. Spraw, by mówili o systemie Tor swoim znajomym.</li>
<li>Jeśli podobają ci się cele Tora,
  <a href="<page donate>">poświęć chwilę, by złożyć dotację, aby wspomóc przyszły rozwój Tora</a>.
  Szukamy też dalszych sponsorów &mdash;
  jeśli znasz jakieś firmy, organizacje pozarządowe, agencje lub inne organizacje, które
  są zainteresowane anonimowością / prywatnością / bezpieczną komunikacją, daj im znać o nas.</li>
<li>Szukamy więcej <a href="<page torusers>">dobrych przykładów użytkowników
 Tora i przypadków jego używania</a>. Jeśli używasz Tora w sposób jeszcze nie przedstawiony
 na tamtej stronie i nie masz nic przeciw podzieleniu się z nami tym sposobem, z chęcią
 przyjmiemy taką wiadomość.</li>
</ol>

<a id="Usability"></a>
<h2><a class="anchor" href="#Usability">Aplikacje Wspomagające</a></h2>
<ol>
 <li>Potrzebujemy więcej i lepszych sposobów na przechwytywanie żądań DNS, żeby nie
 "przeciekały" do lokalnych obserwatorów, podczas gdy chcemy zachować anonimowość.
 (Dzieje się tak, gdyż aplikacja wysyła żądanie DNS przed przejściem przez serwer
 Proxy SOCKS.)</li>
<li>Sprawy z Tsocks/dsocks:
 <ul>
<li>Musimy <a
 href="https://wiki.torproject.org/noreply/TheOnionRouter/TSocksPatches">zastosować
 nasze wszystkie łaty tsocks do kodu</a> i utrzymywać nową gałąź. Możemy ją hostować, jeśli chcesz.</li>
<li>Powinniśmy załatać program "dsocks" Duga Songa, by używał komend
 <i>mapaddress</i> Tora z interfejsu kontroli, żeby nie marnować przejścia
 całej trasy w Torze, wykonując rozwiązywanie adresów przed połączeniem.</li>
<li>Musimy sprawić, by nasz skrypt <i>torify</i> wykrywał, który z programów
 tsocks lub dsocks jest zainstalowany, i odpowiednio je uruchamiał. To
 prawdopodobnie oznacza zunifikowanie ich interfejsów i w grę może wchodzić
 dzielenie kodu między nimi lub całkowita rezygnacja z jednego z nich.</li>
</ul>
</li>
<li>Ludzie, którzy uruchomili przekaźnik sieci Tora mówią nam, że chcą dać jedną
 przepustowość łącza dla Tora (BandwidthRate) w czasie pewnej części dnia,
 a inną w innych częściach dnia. Zamiast programować to w Torze, powinniśmy mieć
 mały skrypt, który łączy się przez <a href="<page gui/index>">Tor Controller Interface</a>,
 i wykonuje SETCONF by zmienić przepustowość. Jest już po jednym skrypcie dla systemów
 Unix i Mac (korzystają z basha i crona), ale dalej potrzebne jest rozwiązanie
 dla użytkowników Windowsa.
 </li>
<li>A mówiąc o danych geolokacyjnych, ktoś powinien narysować mapę Ziemi z
 zaznaczonym każdym przekaźnikiem sieci Tora. Dodatkowe punkty, jeśli mapa będzie się
 aktualizować w miarę jak sieć rośnie i się zmienia. Niestety, łatwy sposób na
 dokonanie tego to wysłanie wszystkich danych do Google, w celu narysowania
 przez nich taj mapy. Jak bardzo to uderza w prywatność i czy mamy jakieś inne
 dobre wyjścia?</li>
</ol>

<a id="Documentation"></a>
<h2><a class="anchor" href="#Documentation">Dokumentacja</a></h2>
<ol>
<li>Proszę pomóc Mattowi Edmanowi z dokumentacją i dokumentami jak-to-zrobić do
 jego projektu Tor Controller i <a href="http://vidalia-project.net/">Vidalia</a>.</li>
<li>Przejrzyj i udokumentuj
 <a href="https://wiki.torproject.org/wiki/TheOnionRouter/TorifyHOWTO">naszą
 listę programów</a>, które można skonfigurować do współpracy z Torem.</li>
<li>Potrzebujemy lepszej dokumentacji do dynamicznego przechwytywania połączeń
 i wysyłania ich przez Tora. tsocks (Linux), dsocks (BSD),
 i freecap (Windows) zdają się być dobrymi kandydatami, jako że lepiej
 używałyby naszej nowej cechy TransPort.</li>
<li>Mamy ogromną listę <a
 href="https://wiki.torproject.org/noreply/TheOnionRouter/SupportPrograms">potencjalnie
 użytecznych programów, które współpracują z Torem</a>. Które z nich są
 przydatne w jakich sytuacjach? Proszę pomóż nam je testować i zapisuj
 swoje wyniki.</li>
<li>Pomóż przetłumaczyć stronę WWW i dokumentację na inne języki. Spójrz na
 <a href="<page translation>">wskazówki do
 tłumaczenia</a>, jeśli chcesz pomóc. Potrzebujemy zwłaszcza tłumaczy na język
 arabski i Farsi dla wielu użytkowników Tora w cenzorowanych obszarach.</li>

</ol>

<a id="Coding"></a>
<a id="Summer"></a>
<a id="Projects"></a>
<h2><a class="anchor" href="#Projects">Dobre Projekty Programistyczne</a></h2>

<p>
Oto lista pomysłów zaproponowanych na <a
href="<page gsoc>">Google Summer of Code 2009</a>.
Części <a href="<svnsandbox>doc/spec/proposals/">bieżących propozycji</a>
może też brakować deweloperów. Jeśli Twoim zdaniem możesz nam pomóc,
<a href="<page contact>">daj nam znać!</a>
</p>


<ol>

<li>
<b>Ulepszenie Skanera Węzłów Tora (Tor Node Scanner)</b>
<br />
Podobnie do skanera wyjściowego SoaT (lub może nawet w czasie jego działania),
można gromadzić statystyki odnośnie wiarygodności węzłów. Te węzły, które
źle działają dla pewnej części swoich obwodów nie powinny być używane do
statusu Strażnika, i być może powinny też mieć zmniejszoną swoją zgłaszaną
przepustowość, lub po prostu być oznaczane jako Nieważne. Dodatkowo,
węzły wykazujące bardzo niską średnią przepustowość strumienia,
lecz zgłaszają bardzo wysoką, też mogą być oznaczone jako Nieważne.
Większość zbierania statystyk już jest zrobiona, dane te muszą tylko
zostać przetworzone na coś, co może być wysłane Serwerom Katalogowym,
by ukarały/wyłączyły ze swoich list te węzły w taki sposób, że klienci
się o tym dowiedzą.
<br />
Dodatkowo, te same statystyki mogą być zbierane odnośnie ruchu przechodzącego
przez węzeł. Do <a
href="https://svn.torproject.org/svn/torctl/trunk/doc/howto.txt">Protokołu Kontroli
Tora</a> można dodać zdarzenia mówiące, czy udaje się stworzyć obwód
przechodzący przez ten węzeł, oraz można zbierać pasywne statystyki dotyczące
zarówno przepustowości, jak i wiarygodności innych węzłów, poprzez oparty
na węzłach program monitorujący takie zdarzenia. Taki skaner zgłaszałby też
informacje o dziwnie zachowujących się węzłach do Serwerów Katalogowych,
ale kanał łączności do tych celów jeszcze nie istnieje i też musiałby
zostać stworzony.
</li>

<li>
<b>Pomóż śledzić ogólny status Sieci Tora</b>
<br />
Byłoby wspaniale uruchomić automatyczny system śledzenia stanu sieci w czasie,
wyświetlanie wykresów itp. Częścią tego projektu byłoby wynalezienie lepszych
miary do oceny stanu i wzrostu sieci. Czy wzrasta średni czas działania sieci?
Ile węzłów kwalifikuje się do bycia Strażnikami w tym miesiącu w porównaniu z
ubiegłym? Jaka jest rotacja w sensie pojawiania się nowych węzłów i znikania
starych? Okresowo ludzie gromadzą krótkie migawki stanu, ale to robi się naprawdę
interesujące dopiero, gdy zaczynamy śledzić te dane w czasie.
<br />
Dane powinny być zbierane z powyższego narzędzia "Skaner Węzłów Tora", z
deskryptorów serwerów, które są publikowane przez każdy przekaźnik i z innych
źródeł. Wyniki w czasie mogłyby być zintegrowane z jedną ze stron opisujących
<a href="https://torstatus.blutmagie.de/">Stan Tora</a> lub być trzymane osobno.
Skoro mówimy o stronach stanu Tora, spójrzcie na
<a href="http://archives.seul.org/or/talk/Jan-2008/msg00300.html">listę życzeń
stanu Tora</a> napisaną przez Rogera.
</li>

<li>
<b>Lepsze wsparcie i pakowanie dla Debiana</b>
<br />
Vidalia obecnie nie współpracuje dobrze na Debianie i Ubuntu z domyślnymi
paczkami Tora. Bieżące paczki Tora automatycznie uruchamiają Tora jako demona
systemowego z konta użytkownika debian-tor i (rozsądnie) nie mają zdefiniowanego
ControlPort w domyślnym torrc. Stąd Vidalia będzie próbować uruchomić własny
proces Tora, bo nie może połączyć się z istniejącym, po czym proces Tora
uruchomiony przez Vidalię zamknie się z błędem, którego użytkownik raczej nie zrozumie,
jako że Tor nie będzie mógł podpiąć się pod swoje porty nasłuchowe, które są
już zajęte przez pierwszy proces Tora.
<br />
Bieżące rozwiązanie to albo mówienie użytkownikowi, by zatrzymał istniejący
proces Tora i pozwolił Vidalii uruchomić własny, albo tłumaczenie, jak ustawić
port kontrolny i hasło w pliku torrc. Lepszym rozwiązaniem na Debianie byłoby używanie
ControlSocket Tora, który umożliwia Vidalii komunikowanie się z Torem poprzez
gniazdo w domenie Unix i mógłby być domyślnie włączony w paczkach Tora dla Debiana.
Vidalia może wtedy uwierzytelnić się do Tora używając ciasteczek, jeśli użytkownik
uruchamiający Vidalię jest w grupie debian-tor.
<br />
Pierwsza część tego projektu będzie polegała na dodaniu obsługi ControlSocket
do Vidalii. Potem student stworzy i przetestuje paczki Vidalii na Debianie i
Ubuntu, które będą zgodne ze standardami pakowania w Debianie, oraz upewni się,
że działają dobrze z istniejącymi paczkami Tora. Możemy też stworzyć repozytorium
apt zawierające nowe paczki Vidalia.
<br />
Kolejnym wyzwaniem byłoby znalezienie intuicyjnego sposobu, by Vidalia mogła
zmienić konfigurację Tora (torrc) mimo iż ta jest w <code>/etc/tor/torrc</code>,
a więc nienaruszalna. Najlepszy jak dotąd pomysł, na jaki wpadliśmy, to
przekazanie Torowi nowej konfiguracji poprzez ControlSocket w czasie uruchamiania
Vidalii, ale jest to zły pomysł, gdyż Tor za każdym razem uruchamia się z inną
konfiguracją niż użytkownik by tego chciał. Drugi najlepszy pomysł jest taki, by
Vidalia stworzyła tymczasowy plik konfiguracyjny i poprosiła użytkownika, by
ręcznie przeniósł go do <code>/etc/tor/torrc</code>, ale to jest zły pomysł, gdyż
użytkownicy nie powinni być zmuszani do bezpośredniego zajmowania się plikami.
<br />
Osoba podejmująca się tego projektu powinna znać system pakowania Debiana i
mieć trochę doświadczenia z C++. Uprzednie doświadczenie z Qt będzie przydatne,
ale nie jest wymagane.
</li>

<li>
<b>Polepszanie naszych zdolności opierania się cenzurze</b>
<br />
Wersje 0.2.0.x Tora robią <a
href="<svnsandbox>doc/design-paper/blocking.html">znaczne postępy</a> w opieraniu
się narodowej i firmowej cenzurze. Ale Tor ciągle potrzebuje lepszych mechanizmów w
niektórych częściach projektu anty-cenzurowania. Na przykład, bieżące wersje mogą
nasłuchiwać połączeń tylko na jednym zestawie adres/port na raz. Istnieje
<a href="<svnsandbox>doc/spec/proposals/118-multiple-orports.txt">propozycja
zajęcia się tą sprawą</a> i umożliwienia klientom łączenie się z danym Torem
na wielu adresach i portach, ale wymaga to więcej pracy. Kolejny projekt
przeciw cenzurze to próba uczynienia Tora bardziej odpornym na skanowanie.
W chwili obecnej ktokolwiek może zidentyfikować
<a href="<svnsandbox>doc/spec/proposals/125-bridges.txt">mostki Tora</a>
po prostu łącząc się z nimi, zgodnie z protokołem Tora, i sprawdzając,
czy odpowiadają. By rozwiązać ten problem, mostki mogłyby
<a href="<svnsandbox>doc/design-paper/blocking.html#tth_sEc9.3">udawać serwery
internetowe</a> (HTTP lub HTTPS), gdy łączą się z nimi programy do skanowania portów,
a nie zachowywać się jak mostki do chwili, gdy użytkownik poda klucz specyficzny
dla mostka.
<br />
Ten projekt zawiera wiele badań i projektowania. Jednym z większych wyzwać
będzie zidentyfikowanie i umiejętne wykorzystanie rozwiązań, które oprą
się atakom nawet po tym, jak atakujący pozna projekt, po czym równoważenie
odporności na cenzurę z użytecznością i siłą.
</li>

<li>
<b>Framework automatycznej aktualizacji programów Tor/Polipo/Vidalia.</b>
<br />
Potrzebujemy dobrego frameworka automatycznej aktualizacji.
Vidalia już ma możliwość informowania, że użytkownik używa przestarzałej lub
niezalecanej wersji Tora. W chwili obecnej Vidalia po prostu pokazuje małe
okienko, które informuje użytkownika, że powinien dokonać ręcznej aktualizacji.
Celem tego projektu jest rozszerzenie Vidalii o możliwość pobrania i
zaktualizowania nowej wersji Tora za użytkownika. Jeśli czas pozwoli,
chcielibyśmy móc aktualizować też inne aplikacje z paczek, jak Polipo czy
Vidalia.
<br />
By wykonać ten projekt, student będzie musiał najpierw poznać istniejące
mechanizmy aktualizacji (np. Sparkle na OS X), by zbadać ich mocne i słabe punkty,
cechy bezpieczeństwa i możliwości zintegrowania z Vidalią. Jeśli żaden nie okaże
się przydatny, student zaprojektuje własny framework aktualizacyjny,
udokumentuje projekt i przedyskutuje go z innymi deweloperami na temat
jego bezpieczeństwa. Potem zaimplementuje go (lub zintegruje istniejący)
i przetestuje.
<br />
Osoba podejmująca się tego projektu powinna dobrze znać C++.
Uprzednie doświadczenie z Qt będzie przydatne, ale nie jest wymagane.
Powinno się mieć też podstawowe pojęcie o powszechnych praktykach
bezpieczeństwa, jak weryfikacja podpisu paczki. Dobre zdolności w
pisaniu też są ważne w tym projekcie, gdyż ważnym krokiem będzie
zrobienie dokumentacji projektu do przejrzenia i przedyskutowania
z innymi ludźmi przed implementacją.
</li>

<li>
<b>Poprawiona i bardziej użyteczna mapa sieci w programie Vidalia</b>
<br />
Jedną z istniejących cech Vidalii jest mapa sieci, która pokazuje użytkownikowi
przybliżone lokalizacje geograficzne przekaźników sieci Tora i rysuje
ścieżki, przez które przechodzi ruch użytkownika w sieci Tora.
Mapa jest w tej chwili niezbyt interaktywna i ma raczej słabą grafikę.
Wolelibyśmy użyć widgetu Marble z KDE, który daje mapę lepszej jakości i
umożliwia lepszą interaktywność, jak na przykład pozwalanie użytkownikowi na
klikanie w poszczególne przekaźniki lub obwody, by wyświetlić dodatkowe
informacje. Moglibyśmy też rozważyć dodanie możliwości klikania przez
użytkownika na dany przekaźnik lub kraj z co najmniej jednym przekaźnikiem i
stwierdzenia "chcę, by moje połączenia do foo.com wychodziły stąd."
<br />
Podczas tego projektu, osoba najpierw zapozna się z Vidalią i API widgetu
Marble. Potem zintegruje widget z Vidalią i zmieni go, by bardziej pasował
do naszych zastosowań, np. można było klikać w obwody, zapisywać mapy we
własnym katalogu Vidalii i dostosować część okien dialogowych widgetu.
<br />
Osoba podejmująca się tego projektu powinna dobrze znać C++.
Uprzednie doświadczenie z Qt i CMake będzie przydatne, ale nie jest wymagane.
</li>

<li>
<b>Interfejs zdarzeń stanu kontrolera Tora</b>
<br />
Jest pewna liczba zmian stanu, o których użytkownik powinien być może być
informowany. Na przykład, jeśli użytkownik chce uruchomić przekaźnik sieci Tor,
a Tor stwierdzi, że nie jest on osiągalny z zewnątrz, użytkownik powinien zostać
o tym poinformowany. W tej chwili wszystko, co dostaje użytkownik, to kilka
wiadomości w "dzienniku wiadomości" Vidalii, których pewnie nie zobaczy, gdyż
nie dostaje informacji, że coś poszło nie tak. Nawet jeśli użytkownik spojrzy na
zapis logów, większość wiadomości będzie miała mały sens dla początkującego.
<br />
Tor ma możliwość informowania Vidalii o wielu takich zmianach stanu, a ostatnio
zaimplementowaliśmy obsługę kilku takich zdarzeń. Jednak jest wiele więcej
zdarzeń, o których użytkownik powinien być informowany i potrzebujemy
lepszego interfejsu użytkownika do wyświetlania takich wiadomości.
<br />
Celem tego projektu jest zaprojektowanie i zaimplementowanie interfejsu
użytkownika do wyświetlania wiadomości o stanie Tora. Na przykład, można
byłoby umieścić mały znaczek na ikonie Vidalii w zasobniku, który alarmowałby
użytkownika o nowych zmianach stanu, którym powinien się przyjrzeć.
Podwójne kliknięcie tej ikonki pokazywałoby okienko dialogowe podsumowujące
ostatnie zmiany stanu prostymi słowami i może sugerujące rozwiązania
do negatywnych wiadomości, jeśli mogą one być naprawione przez użytkownika.
Oczywiście to tylko przykład i można zaproponować inne podejście.
<br />
Osoba podejmująca się tego projektu powinna dobrze znać projektowanie i
tworzenie interfejsu użytkownika i mieć trochę doświadczenia z C++.
Uprzednie doświadczenie z Qt i Qt Designer będzie przydatne, ale nie jest wymagane.
Przydatne mogą być też pewne umiejętności w pisaniu po angielsku, gdyż
ten projekt prawdopodobnie będzie wymagał napisania małej ilości dokumentacji
pomocniczej, która powinna być zrozumiała dla nie-technicznych użytkowników.
Dodatkowe punkty za jakiś projekt graficzny /Photoshop fu, gdyż moglibyśmy
chcieć/potrzebować nowych ikonek.
</li>

<li>
<b>Ulepszenia naszego aktywnego testera konfiguracji przeglądarek</b> -
<a href="https://check.torproject.org">https://check.torproject.org</a>
<br />
Mamy w tej chwili funkcjonalną stronę www, która sprawdza, czy Tor działa.
Ma jednak parę miejsc, w których działa źle. Wymaga ulepszeń dotyczących
domyślnych języków i funkcjonalności. W chwili obecnej odpowiada tylko po angielsku.
Ponadto, jest to kawał skryptu Perla, który nigdy nie powinien był ujrzeć światła
dziennego. Strona powinna prawdopodobnie zostać przepisana w Pythonie
z uwagą na wielojęzyczności. Teraz używa <a
href="http://exitlist.torproject.org/">listy punktów wyjściowych Tor DNS</a>
i powinna to robić w przyszłości. Może to dawać fałszywe pozytywne wyniki - te
powinny zostać wykryte, udokumentowane i naprawione, gdzie to będzie możliwe.
Ktokolwiek pracujący nad tym projektem powinien interesować się DNS,
znać podstawy Perla lub lepiej - Pythona. Będzie musiał tylko minimalnie
stykać się z Torem, by testować swój kod.
<br />
Jeśli chcesz, by ten projekt był bardziej ekscytujący i zawierał więcej
projektowania i programowania, przeczytaj <a
href="<svnsandbox>doc/spec/proposals/131-verify-tor-usage.txt">propozycję
131-verify-tor-usage.txt</a>.
</li>

<li>
<b>Ulepszenia w naszej usłudze punktów wyjściowych Tora - DNS Exit List</b> -
<a href="http://exitlist.torproject.org">http://exitlist.torproject.org</a>
<br />
<a href="http://p56soo2ibjkx23xo.onion/">Oprogramowanie</a> to zostało
napisane przez naszego wspaniałego wolontariusza - Tup.
Jest to serwer DNS napisany w języku Haskell, obsługujące część naszego <a
href="<svnsandbox>doc/contrib/torel-design.txt">dokumentu
projektowania listy punktów wyjściowych</a>. W chwili obecnej, usługa jest
funkcjonalna i używana przez check.torproject.org i innych użytkowników. Sprawy,
które zostały do zrobienia to głównie estetyka. Tej wspaniałej usłudze przydałaby
się o wiele lepsza strona z motywem wspólnym dla stron Tora. Lepiej by wyglądała
z lepszą dokumentacją częstych usług korzystających z RBL. Przydałby się rozgłos.
Osoba pracująca nad tym projektem powinna interesować się DNS, podstawową konfiguracją
RBL dla popularnych usług i pisaniem dokumentacji. Osoba ta wymagałaby tylko minimalnego
stykania się z Torem &mdash; co najmniej podczas testowania własnej dokumentacji.
Ponadto, byłoby dobrze, gdyby interesowała się Haskellem i chciała zaimplementować
więcej z sugestii w dokumencie torel-design.txt.
</li>

<li>
<b>Testowanie integracji Tora z przeglądarkami dla użytkowników końcowych</b>
<br />
Projektowi Tor brakuje obecnie solidnego testu do upewnienia się, że
użytkownik poprawnie skonfigurował przeglądarkę. Taki test powinien sprawdzać
tyle elementów, ile się da. Powinien spróbować zdjąć ukrycie użytkownika
na każdy możliwy sposób. Dwie aktualne strony śledzące takie sprawy są
prowadzone przez Grega i HD Moore'a. Greg trzyma ładną <a
href="http://pseudo-flaw.net/tor/torbutton/">listę problemów wraz z dowodami
jak ich użyć oraz listę błędów itp.</a>. HD Moore prowadzi
<a href="http://www.decloak.net/">stronę metasploit
decloak</a>. Osoba zainteresowana obroną Tora mogłaby zacząć od
zbierania jak największej liczby działających i znanych metod odkrywania
użytkownika Tora. (<a href="https://torcheck.xenobite.eu/">Ta strona</a> może być
pomocna na początek.) Powinno się znać częste pułapki, ale też myśleć o
nowych metodach "zdejmowania" osłony użytkowników. Strona powinna
informować użytkownika, w czym ma problem. Powinna pomóc mu w naprawieniu
problemu lub skierować go na właściwe kanały wsparcia. Osoba wykonująca powinna
dobrze znać Tora i to, jak zapobiegać wyciekom.
</li>

<li>
<b>Lepsza integracja Tora i Libevent</b>
<br />
Tor powinien lepiej używać nowych cech biblioteki
<a href="http://monkey.org/~provos/libevent/">Libevent</a> Nielsa Provosa.
Tor już używa Libevent do niskopoziomowych funkcji wejścia/wyjścia i mógłby użyć
coraz lepszych implementacji buforów sieciowych i HTTP. Nie byłaby to po prostu
kwestia zastąpienia wewnętrznych funkcji Tor wywołaniami funkcji z Libevent -
zamiast tego musimy zmienić Tora, by używał wywołań Libevent, które nie
trzymają się modelu istniejących funkcji. Ponadto, będzie trzeba dodać pewne
funkcjonalności do Libevent, jeśli będzie trzeba &mdash; prawdopodobnie
najtrudniejsze będzie dodanie obsługi OpenSSL na abstrakcje buforów w Libevent.
Niełatwe również będzie dodanie ograniczanie transferu do Libevent.
</li>

<li>
<b>Tuneup Tor!</b>
<br />
W chwili obecnej węzły Tora mierzą i zgłaszają własną przepustowość łącza,
a klienci Tora wybierają, których węzłów używać po części opierając się
na tej zgłaszanej przepustowości. To podejście jest podatne na
<a href="http://freehaven.net/anonbib/#bauer:wpes2007">ataki, w których węzły oszukują
na temat przepustowości swoich łączy</a>; by to zmienić, Tor aktualnie ogranicza
maksymalną przepustowość każdego węzła, w którą jest w stanie uwierzyć. To jest
ograniczone rozwiązanie i marnotrawienie przepustowości. Zamiast tego,
Tor powinien w miarę możliwości mierzyć przepustowość łączą w rozproszony sposób,
jak jest napisane w dokumencie
<a href="http://freehaven.net/anonbib/author.html#snader08">"A Tuneup for Tor"</a> autorstwa
Snadera i Borisova. Można byłoby użyć bieżącego kodu testującego, by sprawdzić
odkrycia napisane w tym dokumencie i zweryfikować, w jakim stopniu opisują one
normalnie działającego Tora i określić dobre sposoby na wcielenie tych odkryć
do sieci Tora bez dodawania niepożądanego ruchu wielkości między węzłami a serwerami
katalogowymi.
</li>

<!--
<li>
<b>Polepszenie procesu QA Tora: Ciągła integracja dla paczek pod Windows</b>
<br />
Przydałby się automatyczny system tworzenia paczek dla Windows i być może
innych systemów. Celem posiadania środowiska ciągłej integracji jest
upewnienie się, że Windows nie zostanie w tyle z żadnym z projektów
używanych lub związanych z projektem Tor. Buildbot
może być dobrym rozwiązaniem, gdyż zdaje się obsługiwać te same platformy, co Tor.
Przeczytaj (po angielsku) <a href="http://en.wikipedia.org/wiki/BuildBot">wpis na
Wikipedii dotyczący Buildbota</a>.<br />
Może jednak są lepsze rozwiązania, więc osoba podejmująca się tego zadania
powinna rozważyć inne opcje. Jakakolwiek osoba pracująca nad tym systemem
automatycznego budowania powinna mieć doświadczenie lub chęć do nauczenia
się tego, jak buduje się wszystkie odpowiednie elementy Tora od zera.
Ponadto, ta osoba powinna mieć jakieś doświadczenie w kompilowaniu
programów w Windows, jako że to jest ta część użytkowników, których nie chcemy
zostawiać w tyle. Zadanie będzie wymagała bliskiej pracy z kodem Tora,
ale prawdopodobnie tylko od strony kompilacji, nie pisania.<br />
Ponadto, musimy zautomatyzować nasze testy wydajności dla wszystkich systemów.
Mamy już buildbota (za wyjątkiem Windows &mdash; jak napisane powyżej) do
automatyzacji naszej zwyczajnej integracji i kompilacji testów, ale
musimy zaktualizować nasze testy symulacji sieci (takie, jak w torflow)
do nowszych wersji Tora i zaprojektować je tak, by uruchamiać sieci testowe
albo na jednej maszynie, albo na kilku, abyśmy mogli automatycznie
badać zmiany wydajności na maszynach pełniących różne zadania.<br />
</li>
-->

<li>
<b>Polepszenie procesu testów jednostkowych</b>
<br />
Tor musi zostać znaczniej bardziej przetestowany. To jest projekt wieloczęściowy.
Na początek, nasze testy jednostkowe powinny znacznie się wzbogacić, zwłaszcza
w obszarach poza funkcjami narzędziowymi. Będzie to wymagało poważnych zmian
niektórych części Tora, aby oddzielić jak najwięcej programu od zmiennych
globalnych.<br />
Ponadto, musimy zautomatyzować nasze testy wydajności dla wszystkich systemów.
Mamy już buildbota do automatyzacji naszej zwyczajnej integracji i kompilacji testów
(ale potrzebujemy osoby do uruchomienia tego pod Windows), ale
musimy zaktualizować nasze testy symulacji sieci (takie, jak w TorFlow: spójrz na punkt
"Ulepszenie Skanera Węzłów Tora")
do nowszych wersji Tora i zaprojektować je tak, by uruchamiać sieci testowe
albo na jednej maszynie, albo na kilku, abyśmy mogli automatycznie
badać zmiany wydajności na maszynach pełniących różne zadania.
</li>

<li>
<b>Pomóż wznowić niezależną implementację klienta Tora</b>
<br />
Reanimuj jedno z podejść do implementacji klienta Tora w Javie, np.
<a href="http://onioncoffee.sourceforge.net/">projekt OnionCoffee</a>
i spraw, by działał pod <a href="http://code.google.com/android/">Androidem</a>.
Pierwszym krokiem byłoby przeniesienie istniejącego kodu i uruchomienie go
w środowisku Android. Potem kod powinien zostać zaktualizowany, by obsługiwać
nowsze wersje protokołu Tora, jak na przykład
<a href="<svnsandbox>doc/spec/dir-spec.txt">protokół katalogowy w wersji 3</a>.
Poza tym, obsługa żądań lub choćby dostarczania usług ukrytych Tora byłaby fajna,
choć nie wymagana.<br />
 Perspektywiczny deweloper powinien rozumieć i umieć pisać nowy kod w Javie, łącznie
z korzystaniem z kryptograficznego API Javy. Umiejętność czytania kodu w C
też byłaby przydatna. Powinno się mieć chęć do czytania istniejącej dokumentacji,
implementacji kodu w oparciu o nią oraz, jeśli będzie to potrzebne, poprawiać
dokumentację, jeśli jest niejasna. Ten projekt składa się w dużym stopniu z
pisania kodu i w mniejszym - z projektowania.
</li>

<li>
<b>Ożywienie projektu moniTor</b>
<br />
Zaimplementuj narzędzie <a href="http://www.ss64.com/bash/top.html">podobne do top</a>
dla przekaźników siei Tora. Celem takiego narzędzia byłoby monitorowanie lokalnego przekaźnika
sieci poprzez jego port kontrolny i dołączanie użytecznych informacji systemowych
samej maszyny. Podczas działania, narzędzie to dynamicznie aktualizowałoby
swoje informacje, tak jak program top robi to dla procesów linuksowych.
<a href="http://archives.seul.org/or/dev/Jan-2008/msg00005.html">Ta
wiadomość na or-dev</a> może być dobrą lekturą na początek.<br />
 Obsoba powinna znać lub
być chętną do nauki administrowania przekaźnikiem Tora i konfigurowania go
za pomocą portu kontroli. Jako że wstępny prototyp jest napisany w Pythonie,
pewna wiedza na temat pisania programów w tym języku też byłaby przydatna.
Ten projekt z jednej strony opiera się na określeniu wymagań dla takiego
narzędzia i zaprojektowania dla niego interfejsu, a z drugiej strony
wymaga również dużo programowania.
</li>


<li>
<b>Ulepszenia w Torbutton</b>
<br />
Jest parę ulepszeń, które można byłoby wprowadzić do Torbutton w wersji po 1.2.
Większość z nich jest pisana jako prośby o ulepszenia w <a
href="https://bugs.torproject.org/flyspray/index.php?tasks=all&amp;project=5">sekcji
flyspray Torbuttona</a>. Dobrymi przykładami są: wycinanie node.exit z nagłówków
HTTP, lepsza kontrola blokowania wypełniania formularzy, ulepszone imitowanie
odnośników do stron poprzednich (tzw. referrers) w oparciu o domenę strony
(coś jak <a href="https://addons.mozilla.org/en-US/firefox/addon/953"
>rozszerzenie refcontrol</a>), bliższa integracja z Vidalią do zgłaszania
stanu Tora, przycisk Nowa Tożsamość z integracją z Torem i zarządzanie
wieloma tożsamościami, i cokolwiek jeszcze, co zdołasz wymyślić.
<br />
To zadanie składałoby się z niezależnego pisania w JavaScripcie i miłym
świecie <a
href="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">XUL</a>,
bez zbytniego zagłębiania się do wnętrzności Tora.

</li>

<li>
<b>Przeniesienie Polipo na Windows</b>
<br />
Pomóż przenieść <a
href="http://www.pps.jussieu.fr/~jch/software/polipo/">Polipo</a> na Windows.
1) obsługa spacji w ścieżkach i zrozumienie przestrzeni nazw systemu plików
&mdash; przestrzeń nazw tu oznacza gdzie dane aplikacji, dane osobiste i
program zwykle się znajdują w różnych wersjach Windows. 2) zdolność obsługi
połączeń przez IPv6. 3) zdolność do asynchronicznego wysyłania zapytań do
serwerów nazw. 4) używanie natywnych zdolności Windows odnośnie wyrażeń regularnych
zamiast używania bibliotek GNU. 5) natywna obsługa zdarzeń i buforów (tj. w
systemach uniksopodobnych Polipo domyślnie używa 25% pamięci RAM, a pod Windows
jest to cokolwiek wpisane w plik konfiguracyjny). 6) jakieś narzędzie z
graficznym interfejsem do konfiguracji i raportowania, dodatkowe punkty, jeśli
ma ikonkę w zasobniku z opcjami menu po kliknięciu prawym przyciskiem myszy.
Podwójny bonus, jeśli działa na wielu platformach.
</li>

<li>
<b>Zrobienie naszych diagramów pięknymi i zautomatyzowanymi</b>
<br />
Potrzebujemy sposobu na generowanie diagramów na stronie (na przykład, obrazków
"Jak działa Tor" na <a href="<page overview>">stronie wprowadzenia</a>
ze źródeł, byśmy mogli je tłumaczyć
jako tekst w UTF-8 zamiast edytować je ręcznie za pomocą GIMPa.
Należy zintegrować to z plikiem WML, by tłumaczenie było proste, a obrazki
generowane w wielu językach w czasie publikacji strony.
</li>

<li>
<b>Ulepszenie oferty LiveCD dla społeczeństwa Tora</b>
<br />
<li>Jak można uczynić <a
href="http://anonymityanywhere.com/incognito/">Incognito LiveCD</a>
łatwiejszym w utrzymaniu, ulepszaniu i dokumentowaniu?</li>

<li>
<b>Zmiana i rozszerzenie Blossom</b>
<br />
Należy zmienić i rozszerzyć Blossom (narzędzie do monitorowania i wybierania
właściwych obwodów Tora w oparciu o wymagania co do węzła wyjściowego podane
przez użytkownika) do zbierania danych własnym sposobem, z łatwymi do zmiany
przez użytkownika parametrami. Blossom jest aktualnie zaimplementowany
jako pojedynczy skrypt Pythona, który łączy się z Torem używając interfejsu
Kontrolera i opiera się na danych zbieranych o węzłach Tora przez zewnętrzne
procesy takiej jak strona www pokazująca status węzłów wraz z publicznymi
danymi z DNSów, whois itp. Ten projekt ma 2 części: (1) Określenie, jakie jeszcze
dane mogą być potrzebne i przerobić Blossom tak, by sam zbierał dane zamiast polegać
na zewnętrznych skryptach (to może, oczywiście, wprowadzić dodatkowe wątki i
komunikację międzyprocesową) i (2) stworzenie metody łatwej konfiguracji Blossom
przez użytkownika, zaczynając od pliku konfiguracyjnego i być może kończąc na
konfiguracji przez przeglądarkę. Ważna jest znajomość Tora i Pythona; znajomość
TCP, komunikacji międzyprocesowej i Perla też może się przydać. Zainteresowanie
neutralnością sieci też jest ważne, gdyż zasady ewolucji i zrozumienie
niespójności Internetu są podstawą projektu Blossom.
</li>

<li>
<b>Ulepszenie Blossom: pozwolenie użytkownikom na jakościowy opis węzłów wyjściowych,
z których chcą korzystać</b>
<br />
Należy zaprojektować i zaimplementować możliwość dania użytkownikom programu Blossom
opisania węzła wyjściowego, z którego chcą korzystać. Internet jest niespójnym
miejscem: niektóre węzły wyjściowe Tora widzą świat inaczej niż inne. W bieżącej
implementacji Blossom (narzędzie do monitorowania i wybierania
właściwych obwodów Tora w oparciu o wymagania co do węzła wyjściowego podane
przez użytkownika) nie ma dość bogatego języka, by opisać, jak bardzo różne
są różne punkty widzenia. Na przykład, niektóre węzły wyjściowe mogą być w
sieciach filtrujących pewne rodzaje ruchu lub strony. Inne węzły mogą dawać dostęp
do specjalnej zawartości w związku ze swoją lokalizacją, być może jako rezultat
dyskryminacji ze strony samych dostawców treści. Ten projekt składa się z 2 części:
(1) stworzenie języka do opisywania charakterystyk sieci, w której znajdują się
węzły, oraz (2) wprowadzenie tego języka do Blossom, by użytkownicy mogli
wybierać ścieżki Tora w oparciu o ten opis.
Ważna jest znajomość Tora i Pythona; znajomość
TCP, komunikacji międzyprocesowej i Perla też może się przydać. Zainteresowanie
neutralnością sieci też jest ważne, gdyż zasady ewolucji i zrozumienie
niespójności Internetu są podstawą projektu Blossom.
  	 </li>

<li>
<b>Przynieś nowe pomysły!</b>
<br />
<li>Nie podoba ci się żaden z tych pomysłów? Spójrz na <a
 href="<svnsandbox>doc/roadmaps/2008-12-19-roadmap-full.pdf">plan rozwoju Tora</a> po więcej
 pomysłów.</li>
<li>Nie widzisz tu swojego pomysłu? Prawdopodobnie i tak go potrzebujemy! Skontaktuj się
 z nami, by to sprawdzić.</li>
</ol>

<a id="OtherCoding"></a>
<h2><a class="anchor" href="#OtherCoding">Inne pomysły związane z programowaniem i projektowaniem</a></h2>

<ol>

<li>Przekaźniki sieci Tora nie działają zbyt dobrze na Windows XP. Pod systemem Windows Tor
 używa standardowej funkcji systemowej <tt>select()</tt>, która zużywa miejsce
 w niestronicowanym obszarze pamięci. Znaczy to, że średnich rozmiarów
 przekaźnik sieci Tora zapełni dostępną przestrzeń, <a
 href="https://wiki.torproject.org/noreply/TheOnionRouter/WindowsBufferProblems">będąc
 przyczyną dziwnych zachowań i padów systemu</a>. Powinniśmy raczej używać
 nakładającego IO. Jednym z rozwiązań byłoby nauczenie biblioteki <a
 href="http://www.monkey.org/~provos/libevent/">libevent</a>, jak używać nakładającego IO
 zamiast select() pod Windows, po czym zaadaptować Tora do nowego interfejsu.
 Christian King zrobił
 <a href="https://svn.torproject.org/svn/libevent-urz/trunk/">pierwszy dobry
 krok</a> lata roku 2007.</li>

<li>Musimy zacząć budować nasz <a href="<page
 documentation>#DesignDoc">projekt odporny na blokowanie</a>. Wchodzi w to
 przemyślenie projektu, zmiana wielu różnych elementów Tora, zaadaptowanie
 <a href="http://vidalia-project.net/">Vidalii</a>, by obsługiwała nowe cechy i
 planowanie rozpowszechniania.</li>

<li>Potrzebujemy elastycznego frameworka symulacji do badania ataków potwierdzenia
 ruchu od nadawcy do odbiorcy (end-to-end). Wielu ludzi szybko wyciągnęło/napisało doraźne
 symulatory odpowiadające ich intuicji, że albo ataki znakomicie się udają, albo
 że obrona działa dobrze. Czy możemy zbudować symulator, który jest dobrze udokumentowany
 i dość otwarty, by wszyscy wiedzieli, że daje rozsądną odpowiedź? To zacznie wiele nowych
 badań. Spójrz na wpis <a href="#Research">poniżej</a> o atakach potwierdzenia po szczegóły
 strony badawczej tego zadania &mdash; kto wie, może gdy będzie skończone, pomożesz nam też
 napisać dokumentację.</li>

<li>Tor 0.1.1.x i późniejsze zawiera obsługę sprzętowych akceleratorów kryptograficznych,
 poprzez OpenSSL. Ale nikt tego jeszcze nie przetestował. Czy ktoś chce
 zdobyć kartę i powiadomić nas, jak to działa?</li>

<li>Dokonać analizy bezpieczeństwa Tora z <a
 href="http://en.wikipedia.org/wiki/Fuzz_testing">"fuzz"</a>. Sprawdzić, czy
 istnieją jakieś dobre biblioteki "fuzz", których nam potrzeba. Zdobądź sławę
 gdy wydamy nową wersję dzięki Tobie!</li>

<li>Tor używa TCP do transportu i TLS do szyfrowania transmisji. To jest
 ładne i proste, ale oznacza to, że wszystkie komórki na łączu zostają
 opóźnione, gdy pojedynczy pakiet zostanie utracony, co oznacza, że rozsądnie
 obsługiwać możemy tylko strumienie TCP. Mamy <a
 href="https://wiki.torproject.org/noreply/TheOnionRouter/TorFAQ#TransportIPnotTCP">listę
 powodów, dla których nie przenieśliśmy się na UDP</a>, ale byłoby dobrze
 skrócić tę listę. Mamy też proponowaną <a
 href="<svnsandbox>doc/spec/proposals/100-tor-spec-udp.txt">specyfikację dla Tora i
 UDP</a> &mdash; proszę dać znać, co z nią jest nie tak.</li>


<li>Jesteśmy wcale niedaleko od obsługi adresów IPv6 jako docelowych (na węzłach
 wyjściowych). Jeśli mocno ci zależy na IPv6, to jest to chyba najlepszy punkt
 startu.</li>
</ol>

<a id="Research"></a>
<h2><a class="anchor" href="#Research">Badania</a></h2>
<ol>
<li>"Atak na odciski palców stron WWW" (website fingerprinting attack): sporządź listę kilkuset
 popularnych stron WWW, ściągnij ich strony i zrób listę "podpisów"
 dla każdej z nich. Potem obserwuj ruch sieciowy klienta Tora. Jak
 patrzysz na odbierane przez niego dane, szybko zgadujesz, którą
 (jeśli w ogóle) on odbiera. Po pierwsze, jak bardzo ten atak jest
 efektywny? Potem zacznij badać sposoby obrony: na przykład, moglibyśmy
 zmienić rozmiar komórki Tora z 512 na 1024 bajty, moglibyśmy użyć
 technik dopełniających, jak <a
 href="http://freehaven.net/anonbib/#timing-fc2004">odrzucanie obronne (defensive dropping)</a>,
 lub moglibyśmy dodać opóźnienia w ruchu. Jak wielki wpływ mają te
 rozwiązania i jak wielki wpływ na używalność (używając odpowiedniego
 sposobu mierzenia) ma udana obrona w każdym z przypadków?
</li>
<li>"Atak potwierdzenia w ruchu nadawca-odbiorca" (end-to-end traffic confirmation attack):
 obserwując ruch od Alicji do Boba, możemy <a
 href="http://freehaven.net/anonbib/#danezis:pet2004">porównać
 sygnatury ruchu i przekonać się, że obserwujemy ciągle ten sam strumień danych</a>.
 Jak na razie, Tor przyjmuje to jako pewnik i zakłada, że ten atak jest
 trywialny we wszystkich przypadkach. Po pierwsze, czy tak rzeczywiście jest?
 Jak wiele ruchu/danych o jakim rozkładzie jest potrzebne, by przeciwnik
 upewnił się, że wygrał? Czy są jakieś sytuacje (np. nie wysyłanie wiele danych),
 które spowolniłyby atak? Czy jakieś dopełnienia transmisji lub inne sposoby
 kształtowania działają lepiej od innych?
 </li>

<li>Powiązane pytanie brzmi: Czy prowadzenie przekaźnika/mostka daje dodatkową
ochronę przed atakami opartymi na czasie? Czy ktoś z zewnątrz, kto nie może
przeczytać linków zaszyfrowanych przez TLS, dalej jest w stanie prawidłowo rozpoznać
poszczególne strumienie danych? Czy ilość ruchu jakoś zmniejsza tę możliwość?
A co, jeśli klient-przekaźnik celowo opóźnia wychodzący ruch, by stworzyć kolejkę,
która mogłaby być używana do udawania czasów pobierania danych przez klienta tak,
by wyglądało, że ten ruch też jest przekierowany? Ta sama kolejka mogłaby być używana do
maskowania czasów w ruchu wychodzącym, korzystając z technik <a
href="http://www.freehaven.net/anonbib/#ShWa-Timing06">adaptacyjnego dopełniania</a>,
ale bez potrzeby dodatkowego ruchu (wysyłania dodatkowych danych). Czy takie
przeplatanie prawdziwych danych popsułoby mierzenie czasów u atakujących? Czy strategie
te musiałyby by zmienione dla asymetrycznych łączy? Na przykład, czy jest możliwe
na łączu asymetrycznym odróżnienie ruchu klienta od naturalnego wzmożenia ruchu ze
względu na ich asymetryczną pojemność? Czy jest to jednak łatwiejsze niż dla łączy
symetrycznych z innych przyczyn?</li>

<li>Powtórzcie <a
href="http://www.cl.cam.ac.uk/~sjm217/projects/anon/#torta">atak z
Oakland 05</a> Murdocha i Danezisa na bieżącej sieci Tora. Sprawdźcie, czy możecie
dowiedzieć się, czemu działa on dobrze na niektórych węzłach, a gorzej na innych.
(Moja teoria mówi, że szybkie węzły mające trochę wolnego pasma lepiej opierają się
atakowi.) Jeśli to prawda, poeksperymentujcie z opcjami RelayBandwidthRate i
RelayBandwidthBurst prowadząc węzeł używany jako klient do przekierowywania
ruchu atakującego: jeśli zmniejszamy RelayBandwidthRate, czy atak jest trudniejszy?
Jaki jest najwłaściwszy stosunek RelayBandwidthRate do rzeczywistej szybkości
łącza? Czy to w ogóle jest jakiś stosunek? Skoro już przy tym jesteśmy, czy znacznie
większy zbiór węzłów kandydujących zwiększa odsetek fałszywych wyników pozytywnych
lub innych trudności dla tego rodzaju ataku? (Sieć Tora jest teraz większa o prawie
dwa rzędy wielkości niż wtedy, gdy napisano ten dokument.) Przeczytaj też
<a href="http://freehaven.net/anonbib/#clog-the-queue">Nie zapychaj kolejki</a>.</li>

<li>"Atak stref trasowania" (routing zones attack): większość literatury
 mówi o ścieżce sieciowej między Alicją a jej węzłem wejściowym (i między
 węzłem wyjściowym a Bobem) jako o pojedynczej ścieżce na jakimś grafie.
 W rzeczywistości, ścieżka przemierza wiele systemów autonomicznych (SA), i <a
 href="http://freehaven.net/anonbib/#feamster:wpes2004">często zdarza się, że
 ten sam SA pojawia się zarówno na ścieżce wejściowej i wyjściowej</a>.
 Niestety, by dokładnie przewidzieć, czy podany czworobok
 Alicja-wejście-wyjście-Bob jest niebezpieczny, musielibyśmy ściągnąć
 całą strefę trasowania internetu i dokonać na niej czasochłonnych operacji.
 Czy są jakieś praktyczne aproksymacje, jak np. unikanie adresów IP z tej
 samej sieci /8?
 </li>
<li>Inne pytania badawcze dotyczące różnorodności geograficznej rozpatrują
 kompromis między wybieraniem obwodu wydajnego a losowego. Spójrz na <a
 href="http://swiki.cc.gatech.edu:8080/ugResearch/uploads/7/ImprovingTor.pdf">dokument o
 pozycjach</a> Stephena Rollysona na temat tego, jak odrzucać szczególnie wolne
 możliwości bez zbytniej utraty anonimowości. Ta argumentacja wymaga więcej pracy i
 myślenia, ale wygląda bardzo obiecująco.</li>

<li>Tor nie działa za dobrze, gdy przekaźnik sieci ma asymetryczne łącze
 (np. kablówka czy DSL). Ponieważ Tor wykonuje oddzielne połączenia między
 każdym skokiem, jeśli przychodzące bajty są przysyłane dobrze, a wychodzące
 są wyrzucane, mechanizmy push-back w TCP nie transmitują tej informacji
 z powrotem do strumienia przychodzącego. Być może Tor powinien odkryć, gdy
 wyrzuca dużo pakietów wychodzących, i ograniczyć strumienie przychodzące,
 by sam tym regulować? Można sobie wyobrazić schemat działania, w którym
 najpierw wybieramy niski limit przepustowości, powoli go zwiększając aż do
 chwili w której zaczęlibyśmy tracić pakiety - wtedy nastąpiłoby cofnięcie się.
 Potrzebujemy kogoś dobrze znającego sieci by to zasymulował i pomógł
 zaprojektować rozwiązania; musimy zrozumieć stopień degradacji wydajności i
 użyć tego argumentu jako motywacji do ponownego rozpatrzenia transportu UDP.
 </li>
<li>Powiązanym tematem jest kontrola zatorów. Czy nasz dotychczasowy projekt
 okaże się wystarczający, gdy będziemy mieli duży ruch? Może powinniśmy
 poeksperymentować z oknami o zmiennym rozmiarze zamiast z oknami o stałym?
 To zdawało się działać nieźle w <a
 href="http://www.psc.edu/networking/projects/hpn-ssh/theory.php">eksperymencie
 przepustowości SSH</a>. Będziemy musieli mierzyć i podkręcać, i być może
 wykonać poprawki, jeśli wyniki okażą się dobre.
 </li>

<li>Nasze cele w opieraniu się cenzurze to m.in. zapobieganie temu, by napastnik
podglądający ruch Tora mógł <a
href="<svnsandbox>doc/design-paper/blocking.html#sec:network-fingerprint"
>odróżnić go od normalnego ruchu SSL</a>. Oczywiście, nie możemy osiągnąć idealnej
steganografii i dalej mieć użyteczną i działającą sieć, ale w pierwszym kroku
chcielibyśmy blokować jakiekolwiek ataki, które mogą się udać po obserwacji tylko
kilku pakietów. Jednym z pozostałych ataków, którego nie zbadaliśmy za bardzo,
polega na tym, że komórki Tora mają 512 bajtów, więc ruch w sieci może mieć długość
będącą wielokrotnością 512 bajtów. Jak bardzo wkładanie nowych danych
w nagłówkach TLS rozmywa ten fakt w transmisji? Czy inne strategie opróżniania bufora
w Torze mają na to wpływ? Czy trochę dokładania może bardzo pomóc, czy jest o atak,
z którym musimy żyć?</li>

<li>Obwody Tora są budowane po jednym elemencie na raz, więc teoretycznie
 możemy uczynić, aby część strumieni wychodziła z drugiego węzła, część z
 trzeciego itd. To wydaje się dobre, bo ogranicza zbiór strumieni wychodzących,
 które dany przekaźnik sieci może zobaczyć. Ale jeśli chcemy by każdy strumień był
 bezpieczny, "najkrótsza" ścieżka powinna, według naszego bieżącego rozumowania,
 składać się z co najmniej 3 elementów, więc inne będą jeszcze dłuższe.
 Musimy zbadać ten kompromis wydajność/bezpieczeństwo.
 </li>
<li>Nie jest trudno wykonać atak DoS na przekaźniki sieci Tora lub centra katalogowe.
 Zagadki dla klientów (?) (client puzzles) są właściwą odpowiedzią? Jakie są
 inne praktyczne podejścia? Dodatkowe punkty, jeśli są zgodne wstecz z
 bieżącym protokołem Tora.</li>
<li>Programy takie jak <a href="<page torbutton/index>">Torbutton</a>
 mają na celu ukrycie pola UserAgent przeglądarki, zastępując je jednakową odpowiedzią
 dla każdego użytkownika Tora. W ten sposób napastnik nie może złamać anonimowości
 Tora, patrząc na ten nagłówek. Aby się nie wyróżniać, program próbuje wybrać nazwy
 przeglądarek często używanych także przez tych, którzy nie używają Tora.
 Pytanie numer jeden: jak bardzo szkodzimy sami sobie, okresowo zwiększając
 wersję Firefoksa, za którego podaje się Torbutton? Jeśli aktualizujemy zbyt często,
 sami łamiemy swoją anonimowość. Jeśli za rzadko, to wszyscy użytkownicy Tora się
 wyróżniają ze względu na to, że twierdzą, iż używają starych wersji Firefoksa.
 Tutaj odpowiedź zależy pewnie na tym, które wersje Firefoksa są spotykane.
 Pytanie numer dwa: raz na jakiś czas ludzie pytają nas, byśmy krążyli po N
 nazwach UserAgent, zamiast trzymać się jednej. Czy to podejście pomaga, przeszkadza,
 czy nic nie wnosi? Weź pod uwagę: ciaseczka i rozpoznawanie użytkowników Tora poprzez
 ich zmieniające się nagłówki UserAgent, złe strony atakujące tylko określone
 przeglądarki; oraz to, czy odpowiedź na pytanie 1 wpływa na tę odpowiedź.
</li>
<li>W chwili obecnej klienci Tora mogą używać tego samego obwodu w ciągu dziesięciu
minut od jego pierwszego użycia. Celem tego jest uniknięcie przeładowania sieci
zbyt wielką liczbą operacji przedłużania obwodów, równocześnie unikając używania
obwodu tak długo, że węzeł wyjściowy mógłby stworzyć przydatny profil pseudonimowy
użytkownika. Dziesięć minut to jednak prawdopodobnie znacznie za dużo, zwłaszcza
gy przez ten sam obwód prowadzone sa połączenia różnych protokołów (np. IM i przeglądanie
sieci). Jeśli nie zmienimy całkowitej liczby obwodów, które należy utrzymywać, to czy
będą jakieś wydajniejsze lub bezpieczniejsze metody alokcaji strumieni do obwodów,
lub do tworzenia wywłaszczających obwodów? Być może ten temat badań powinien być rozpoczęty
poprzez zebranie śladów, jakie połączenia typowy użytkownik otwiera, by mieć coś
realistycznego do optymalizacji.
</li>
<li>Ile przekaźników mostkowych potrzeba, by utrzymać osiągalność? Powinniśmy zmierzyć
zajętość w naszych mostkach. Jeśli jest duża, czy są jakieś sposoby na zwiększenie
szans użytkowników mostków na pozostanie połączonymi?
</li>

</ol>

<p>
<a href="<page contact>">Daj nam znać</a>, jeśli poczyniłeś postępy nad którąkolwiek z tych rzeczy!
</p>

  </div><!-- #main -->

#include <foot.wmi>


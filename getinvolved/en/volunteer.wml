## translation metadata
# Revision: $Revision$
# Translation-Priority: 4-optional

#include "head.wmi" TITLE="Tor: Volunteer" CHARSET="UTF-8"
<div id="content" class="clearfix">
  <div id="breadcrumbs">
    <a href="<page index>">Home &raquo; </a>
    <a href="<page getinvolved/volunteer>">Volunteer</a>
  </div>
  <div id="maincol"> 
    <!-- PUT CONTENT AFTER THIS TAG -->
    <h1>A few things everyone can do now:</h1>
    <ol>
    <li>Please consider <a href="<page docs/tor-doc-relay>">running
    a relay</a> to help the Tor network grow.</li>
    <li>Tell your friends! Get them to run relays. Get them to run hidden
    services. Get them to tell their friends.</li>
    <li>If you like Tor's goals, please <a href="<page donate/donate>">take a moment
    to donate to support further Tor development</a>. We're also looking
    for more sponsors &mdash; if you know any companies, NGOs, agencies,
    or other organizations that want anonymity / privacy / communications
    security, let them know about us.</li>
    <li>We're looking for more <a href="<page about/torusers>">good examples of Tor
    users and Tor use cases</a>. If you use Tor for a scenario or purpose not
    yet described on that page, and you're comfortable sharing it with us,
    we'd love to hear from you.</li>
    </ol>
    
    <p>Tor has <a href="<page getinvolved/open-positions>">two open positions</a>.
    Please <a href="<page about/contact>">contact us</a> if you are qualified!</p>
    
    <a id="Documentation"></a>
    <h2><a class="anchor" href="#Documentation">Documentation</a></h2>
    <ol>
    <li>Help translate the web page and documentation into other
    languages. See the <a href="<page getinvolved/translation>">translation
    guidelines</a> if you want to help out. We especially need Arabic or
    Farsi translations, for the many Tor users in censored areas.</li>
    <li>Evaluate and document
    <a href="https://trac.torproject.org/projects/tor/wiki/TheOnionRouter/TorifyHOWTO">our
    list of programs</a> that can be configured to use Tor.</li>
    <li>We have a huge list of <a
    href="https://trac.torproject.org/projects/tor/wiki/TheOnionRouter/SupportPrograms">potentially useful
    programs that interface to Tor</a>. Which ones are useful in which
    situations? Please help us test them out and document your results.</li>
    </ol>
    
    <a id="Advocacy"></a>
    <h2><a class="anchor" href="#Advocacy">Advocacy</a></h2>
    <ol>
    <li>Create a <a
href="https://trac.torproject.org/projects/tor/wiki/CommunityLogos">community
logo</a> under a Creative Commons license that all can use and modify.</li>
    <li>Create a presentation that can be used for various user group
meetings around the world.</li>
    <li>Create a video about the positive uses of Tor, what Tor is,
    or how to use it.  Some have already started on <a
    href="http://media.torproject.org/video/">Tor's Media server</a>,
    <a
    href="http://www.howcast.com/videos/90601-How-To-Circumvent-an-Internet-Proxy">Howcast</a>,
    and <a href="http://www.youtube.com/thetorproject">YouTube</a>.</li> 
    <li>Create a poster, or a set of posters, around a theme,
    such as "Tor for Freedom!".</li>
    <li>Create a t-shirt design that incorporates "Congratulations!
    You are using Tor!" in any language.</li>
    </ol>
    
    <a id="Coding"></a>
    <a id="Summer"></a>
    <a id="Projects"></a>
    <h2><a class="anchor" href="#Projects">Good Coding Projects</a></h2>
    
    <p>
    You may find some of these projects to be good <a href="<page
    about/gsoc>">Google Summer of Code 2010</a> ideas. We have labelled each idea
    with how useful it would be to the overall Tor project (priority), how
    much work we expect it would be (effort level), how much clue you should
    start with (skill level), and which of our <a href="<page
    about/corepeople>">core developers</a> would be good mentors.
    If one or more of these ideas looks promising to you, please <a
    href="<page about/contact>">contact us</a> to discuss your plans rather than
    sending blind applications. You may also want to propose your own project
    idea &mdash; which often results in the best applications.
    </p>
    
    <ol>
    
    <li>
    <b>Audit Tor Browser Bundles for data leaks</b>
    <br>
    Priority: <i>High</i>
    <br>
    Effort Level: <i>High</i>
    <br>
    Skill Level: <i>Medium</i>
    <br>
    Likely Mentors: <i>Steven, Erinn, Jacob, Andrew</i>
    <p>The Tor Browser Bundle incorporates Tor, Firefox, Polipo, and the Vidalia
    user interface (and optionally the <a href="http://pidgin.im/">Pidgin</a>
    Instant Messaging client). Components are pre-configured to operate in a
    secure way, and it has very few dependencies on the installed operating
    system. It has therefore become one of the most easy to use, and popular,
    ways to use Tor on Windows.</p>
    <p>This project is to identify all of the traces left behind by
    using a Tor Browser Bundle on Windows, Mac OS X, or Linux.  Developing
    ways to stop, counter, or remove these traces is a final step.</p>
    <p>Students should be familiar with operating system analysis,
    application development on one or preferably all of Windows, Linux,
    and Mac OS X, and be comfortable with C/C++ and shell scripting.</p>
    <p>If you would like to help extend or do security auditing for
    TBB, please contact Erinn.</p>
    </li>
    
    <li>
    <b>Help track the overall Tor Network status</b>
    <br>
    Priority: <i>Medium to High</i>
    <br>
    Effort Level: <i>Medium</i>
    <br>
    Skill Level: <i>Medium</i>
    <br>
    Likely Mentors: <i>Karsten, Roger</i>
    <p>It would be great to set up an automated system for tracking network
    health over time, graphing it, etc. Part of this project would involve
    inventing better metrics for assessing network health and growth. Is the
    average uptime of the network increasing? How many relays are qualifying
    for Guard status this month compared to last month? What's the turnover
    in terms of new relays showing up and relays shutting off? Periodically
    people collect brief snapshots, but where it gets really interesting is
    when we start tracking data points over time.</p>
    <p>Data could be collected from the Tor Network Scanners in <a
    href="https://svn.torproject.org/svn/torflow/trunk/README">TorFlow</a>, from
    the server descriptors that each relay publishes, and from other
    sources. Results over time could be integrated into one of the <a
    href="https://torstatus.blutmagie.de/">Tor Status</a> web pages, or be
    kept separate. Speaking of the Tor Status pages, take a look at Roger's
    <a href="http://archives.seul.org/or/talk/Jan-2008/msg00300.html">Tor
    Status wish list</a>.</p>
    </li>
    
    <li>
    <b>Improving Tor's ability to resist censorship</b>
    <br>
    Priority: <i>Medium to High</i>
    <br>
    Effort Level: <i>Medium to High</i>
    <br>
    Skill Level: <i>High</i>
    <br>
    Likely Mentors: <i>Roger, Nick, Steven</i>
    <p>The Tor 0.2.1.x series makes <a
    href="<svnprojects>design-paper/blocking.html">significant
    improvements</a> in resisting national and organizational censorship.
    But Tor still needs better mechanisms for some parts of its
    anti-censorship design.</p>
    <p>One huge category of work is adding features to our <a
    href="http://gitweb.torproject.org/bridgedb.git?a=tree">BridgeDB</a>
    service (Python). Tor aims to give out <a href="<page docs/bridges>">bridge
    relay addresses</a> to users that can't reach the Tor network
    directly, but there's an arms race between algorithms for distributing
    addresses and algorithms for gathering and blocking them. See <a
    href="<blog>bridge-distribution-strategies">our
    blog post on the topic</a> as an overview, and then look at <a
    href="http://archives.seul.org/or/dev/Dec-2009/msg00000.html">Roger's
    or-dev post</a> from December for more recent thoughts &mdash; lots of
    design work remains.</p>
    <p>If you want to get more into the guts of Tor itself (C), a more minor problem
    we should address is that current Tors can only listen on a single
    address/port combination at a time. There's
    <a href="<gitblob>doc/spec/proposals/118-multiple-orports.txt">a
    proposal to address this limitation</a> and allow clients to connect
    to any given Tor on multiple addresses and ports, but it needs more
    work.</p>
    <p>This project could involve a lot of research and design. One of the big
    challenges will be identifying and crafting approaches that can still
    resist an adversary even after the adversary knows the design, and
    then trading off censorship resistance with usability and
    robustness.</p>
    </li>
    
    <li>
    <b>Tor Controller Status Event Interface for Vidalia</b>
    <br>
    Priority: <i>Medium</i>
    <br>
    Effort Level: <i>Medium</i>
    <br>
    Skill Level: <i>Low to Medium</i>
    <br>
    Likely Mentors: <i>Matt</i>
    <p>There are a number of status changes inside Tor of which the user may need
    to be informed. For example, if the user is trying to set up his Tor as a
    relay and Tor decides that its ports are not reachable from outside
    the user's network, we should alert the user. Currently, all the user
    gets is a couple of log messages in Vidalia's 'message log' window, which they
    likely never see since they don't receive a notification that something
    has gone wrong. Even if the user does actually look at the message log,
    most of the messages make little sense to the novice user.</p>
    <p>Tor has the ability to inform Vidalia of many such status
    changes, and we recently implemented support for a couple of these
    events. Still, there are many more status events which the user should
    be informed of, and we need a better UI for actually displaying them
    to the user.</p>
    <p>The goal of this project then is to design and implement a UI for
    displaying Tor status events to the user. For example, we might put a
    little badge on Vidalia's tray icon that alerts the user to new status
    events they should look at. Double-clicking the icon could bring up a
    dialog that summarizes recent status events in simple terms and maybe
    suggests a remedy for any negative events if they can be corrected by
    the user. Of course, this is just an example and one is free to
    suggest another approach.</p>
    <p>A person undertaking this project should have good UI design and layout
    skills and some C++ development experience. Previous experience with Qt and
    Qt's Designer will be very helpful, but are not required. Some
    English writing ability will also be useful, since this project will
    likely involve writing small amounts of help documentation that should
    be understandable by non-technical users. Bonus points for some graphic
    design/Photoshop fu, since we might want/need some shiny new icons too.</p>
    </li>
    
    <li>
    <b>Improve our unit testing process</b>
    <br>
    Priority: <i>Medium</i>
    <br>
    Effort Level: <i>Medium</i>
    <br>
    Skill Level: <i>Medium</i>
    <br>
    Likely Mentors: <i>Nick, Erinn</i>
    <p>Tor needs to be tested far more thoroughly. This is a
    multi-part effort. To start with, our unit test coverage should
    rise substantially, especially in the areas outside the utility
    functions. This will require significant refactoring of some parts
    of Tor, in order to dissociate as much logic as possible from
    globals.</p>
    <p>Additionally, we need to automate our performance testing. We've got
    buildbot to automate our regular integration and compile testing already
    (though we need somebody to set it up on Windows),
    but we need to get our network simulation tests (as built in <a
    href="https://svn.torproject.org/svn/torflow/trunk/README">TorFlow</a>)
    updated for more recent versions of Tor, and designed to launch a test
    network either on a single machine, or across several, so we can test
    changes in performance on machines in different roles automatically.</p>
    </li>
    
    <li>
    <b>Help with independent Tor client implementations</b>
    <br>
    Priority: <i>Medium</i>
    <br>
    Effort Level: <i>High</i>
    <br>
    Skill Level: <i>Medium to High</i>
    <br>
    Likely Mentors: <i>Bruce, Nathan</i>
    <p>Others are currently working on Tor clients for Java, Android, and Maemo
    environments.  The first step is to get a handle on the current state of
    the project in which you are interested in helping; <a
    href="http://github.com/brl/JTor">Tor for Java</a>,
    <a href="https://svn.torproject.org/svn/projects/android/trunk/">Android/Orbot</a>,
     or <a href="<page docs/N900>">Tor for Maemo</a>. Check out the
    repository and familiarize yourself
    with the source code.  Further, support for requesting or even providing
    Tor hidden services would be neat, but not required.</p>
    <p>A prospective developer should be able to understand and write new Java
    code, including a Java cryptography API. Being able to read C code would be helpful,
    too. One should be willing to read the existing documentation,
    implement code based on it, and refine the documentation
    when things are underdocumented. This project is mostly about coding and
    to a small degree about design.</p>
    </li>

    <li>
    <b>More on Orbot &amp; Android OS-specific development</b>
    <br/>
    <br>
    Priority: <i>Medium</i>
    <br>
    Effort Level: <i>High</i>
    <br>
    Skill Level: <i>Medium to High</i>
    <br>
    Likely Mentors: <i>Nathan</i>
    <p><b>Android Java UI work:</b> Improved home screen to show better
    statistics about data transferred (up/down), number of circuits
    connected, quality of connection and so on. The "Tether Wifi"
    Android application is a good model to follow in how it shows
    a realtime count of bytes transferred as well as notifications
    when wifi clients connect. In addition, better display/handling
    of Tor system/error messages would also be very helpful. Finally,
    the addition of a wizard or tutorial walkthrough for novice
    users to explain to them exactly what is and what is not anonymized
    or protected would greatly improve the likelihood they will use
    Orbot correctly.</p>
    
    <p><b>Android Java OS/Core app work:</b> Better system-wide
    indication, either via the notification bar, "Toast" pop-up dialogs
    or some other indicator, that an application's traffic is indeed
    moving through Orbot/Tor. For instance, right now you need to
    first go to a torcheck web service to ensure your browser is
    routing via Tor. Orbot should be able to notify you that circuits
    are being opened, used, etc. The aforementioned data transfer
    tracker might provide this type of awareness as well.</p>
    
    <p><b>Android Java Library/Community Outreach work:</b> We need
    to package a simple library for use with third-party application
    to easily enable them to support "Torification" on non-rooted
    devices (i.e. w/o transparent proxying). This library should
    include a wrapper for the Apache HTTPClient library, a utility
    class for detecting the state of Orbot connectivity, and other
    relevant/useful things an Android app might need to anonymize
    itself. This work would include the creation of the library,
    documentation, and sample code. Outreach or effort to implement
    the library within other open-source apps would follow.</p>
    
    <p><b>Android OS/C/Linux work:</b> The port of Tor to Android
    is basically a straight cross-compile to Linux ARM. There has
    been no work done in looking the optimization of Tor within a
    mobile hardware environment, on the ARM processor or other
    Android hardware, or on mobile networks. It should be noted,
    that even without optimization, Tor is handling the mobile
    network environment very well, automatically detecting change
    in IP addresses, reconnecting circuits, etc. across switching
    from 2G to 3G to Wifi, and so forth.</p>
    </li>
    
    <li>
    <b>Simulator for slow Internet connections</b>
    <br>
    Priority: <i>Medium</i>
    <br>
    Effort Level: <i>Medium</i>
    <br>
    Skill Level: <i>Medium</i>
    <br>
    Likely Mentors: <i>Steven</i>
    <br>
    Many users of Tor have poor-quality Internet connections, giving low
    bandwidth, high latency, and high packet loss/re-ordering. User
    experience is that Tor reacts badly to these conditions, but it is
    difficult to improve the situation without being able to repeat the
    problems in the lab.
    <br>
    This project would be to build a simulation environment which
    replicates the poor connectivity so that the effect on Tor performance
    can be measured. Other components would be a testing utility to
    establish what are the properties of connections available, and to
    measure the effect of performance-improving modifications to Tor.
    <br>
    The tools used would be up to the student, but dummynet (for FreeBSD)
    and nistnet (for Linux) are two potential components on which this
    project could be built. Students should be experienced with network
    programming/debugging and TCP/IP, and preferably familiar with C and a
    scripting language.
    </li>
    
    <li>
    <b>An Improved and More Usable Network Map in Vidalia</b>
    <br>
    Priority: <i>Low to Medium</i>
    <br>
    Effort Level: <i>Medium</i>
    <br>
    Skill Level: <i>Medium</i>
    <br>
    Likely Mentors: <i>Matt</i>
    <br>
    One of Vidalia's existing features is a network map that shows the user
    the approximate geographic location of relays in the Tor network and
    plots the paths the user's traffic takes as it is tunneled through the
    Tor network. The map is currently not very interactive and has rather
    poor graphics. Instead, we implemented KDE's Marble widget such
    that it gives us a better quality map and enables improved interactivity,
    such as allowing the user to click on individual relays or circuits to
    display additional information. We want to add the ability
    for users to click on a particular relay or a country containing one or
    more Tor exit relays and say, "I want my connections to exit
    from here."
    <br>
    This project will first involve getting familiar with Vidalia
    and the Marble widget's API. One will then integrate the widget
    into Vidalia and customize Marble to be better suited for our application,
    such as making circuits clickable, storing cached map data in Vidalia's
    own data directory, and customizing some of the widget's dialogs.
    <br>
    A person undertaking this project should have good C++ development
    experience. Previous experience with Qt and CMake is helpful, but not
    required.
    </li>
    
    <li>
    <b>Torbutton equivalent for Thunderbird</b>
    <br>
    Priority: <i>Medium</i>
    <br>
    Effort Level: <i>High</i>
    <br>
    Skill Level: <i>High</i>
    <br>
    Likely Mentors: <i>Mike</i>
    <br>
    We're hearing from an increasing number of users that they want to use
    Thunderbird with Tor. However, there are plenty of application-level
    concerns, for example, by default Thunderbird will put your hostname in
    the outgoing mail that it sends. At some point we should start a new
    push to build a Thunderbird extension similar to Torbutton.
    </li>
    
    <li>
    <b>Improvements for Tor+Vidalia interaction on Linux/Unix platforms</b>
    <br>
    Priority: <i>Medium</i>
    <br>
    Effort Level: <i>Medium</i>
    <br>
    Skill Level: <i>Medium</i>
    <br>
    Likely Mentors: <i>Erinn, Peter</i>
    <br>
    Vidalia currently doesn't play nicely with Tor on Linux and Unix platforms.
    Currently, on Debian and Ubuntu, there is a configuration mechanism which
    allows Vidalia to override Tor's ability to start on boot (by sourcing
    <code>/etc/default/tor.vidalia</code> which sets <code>RUN_DAEMON=no</code> at the user's
    request), but full implementation of <a href="<gitblob>doc/spec/control-spec.txt">ControlPort</a> 
    communication is still required.
    <br>
    A better solution on Linux and Unix platforms would be to use Tor's
    ControlSocket, which allows Vidalia to talk to Tor via a Unix domain socket,
    and could possibly be enabled by default in Tor's distribution packages.
    Vidalia can then authenticate to Tor using filesystem-based (cookie)
    authentication if the user running Vidalia is also in the distribution-specific
    tor group.
    <br>
    This project will first involve adding support for Tor's ControlSocket to
    Vidalia. The student will then develop and test this support on various
    distributions to make sure it behaves in a predictable and consistent manner on
    all of them.
    <br>
    The next challenge would be to find an intuitive and usable way for Vidalia to be
    able to change Tor's configuration (torrc) even though it is located in
    <code>/etc/tor/torrc</code> and thus immutable. In Debian and Ubuntu we handle
    this with the aforementioned <code>/etc/default/tor.vidalia</code> but this
    functionality could (or should) be less distribution-specific. 
    <br>
    The best idea we've come up with so far is to feed Tor a new configuration via
    the ControlSocket when Vidalia starts, but that's bad because if the user is not
    using the latest Debian/Ubuntu packages, they may not have disabled Tor's
    ability to run on boot and will end up with a configuration that is different
    from what they want. The second best idea we've come up with is for Vidalia to
    write out a temporary torrc file and ask the user to manually move it to
    <code>/etc/tor/torrc</code>, but that's bad because users shouldn't have to
    mess with files directly.
    <br>
    A person undertaking this project should have prior knowledge of various Linux
    distributions and their packaging mechanisms as well as some C++ development
    experience. Previous experience with Qt is helpful, but not required.
    </li>
    
    
    <li>
    <b>Usability testing of Tor</b>
    <br>
    Priority: <i>Medium</i>
    <br>
    Effort Level: <i>Medium</i>
    <br>
    Skill Level: <i>Low to Medium</i>
    <br>
    Likely Mentors: <i>Andrew</i>
    <br>
    Especially the browser bundle, ideally amongst our target demographic.
    That would help a lot in knowing what needs to be done in terms of bug
    fixes or new features. We get this informally at the moment, but a more
    structured process would be better.
    </li>
    
    <li>
    <b>An authenticating IRC proxy</b>
    <br>
    Priority: <i>Low</i>
    <br>
    Effort Level: <i>Medium to High</i>
    <br>
    Skill Level: <i>Medium to High</i>
    <br>
    Likely Mentors: <i>Sebastian, Weasel, Roger</i>
    <br>
    The world needs an authenticating irc proxy. As we're periodically
    reminded from the Penny Arcade web comic, "Internet user + anonymity =
    jerk". With respect to websites we're actually doing ok, since websites
    can make their users log in and use other application-level authentication
    approaches. But IRC servers are much worse off, because most IRC server
    code is poorly written: hard to maintain, and harder to modify. Many
    IRC networks now block connections from Tor, and we're basically down to
    two holdouts (OFTC and Freenode). This state of affairs means that a lot
    of people around the world are thinking "I told you so" about anonymity
    online, when in fact the problem is simply lack of technology to make the
    problem manageable. We need some way to let the IRC networks distinguish
    which users have developed a reputation as not being jerks, so they can
    treat the two groups separately. There are some really cool research
    designs like <a href="http://www.cs.dartmouth.edu/~nymble/">Nymble</a>,
    which aim to let websites blacklist users without needing to learn who
    they are.  But Nymble is designed around web interactions. We need to
    build the glue around the IRC protocol that would let us plug in a project
    like Nymble (or a simpler one to start, as a proof-of-concept). One way
    to do that would be to build an IRC proxy that knows how to hear from
    IRC clients, knows how to talk to IRC servers, and has an additional
    layer that requires the users to authenticate.  Some work on this has
    begun by other volunteers, see their progress at <a
    href="http://github.com/anonirc/orc">http://github.com/anonirc/orc</a>.
    </li>
    
    <li>
    <b>Make torsocks/dsocks work on OS X</b>
    <br>
    Priority: <i>Medium</i>
    <br>
    Effort Level: <i>Medium</i>
    <br>
    Skill Level: <i>Medium</i>
    <br>
    Likely Mentors: <i>?</i>
    <br>
    <a href="http://code.google.com/p/torsocks/">Torsocks</a> and <a
    href="http://code.google.com/p/dsocks/">dsocks</a> are wrappers that will
    run applications, intercept their outgoing network connections, and push
    those connections through Tor. The goal is to handle applications that
    don't support proxies (or don't supporting them well). To get it right,
    they need to intercept many system calls. The syscalls you need to
    intercept on Linux differ dramatically from those on BSD. So Torsocks
    works fine on Linux, dsocks works ok on BSD (though it may be less
    maintained and thus might miss more syscalls), and nothing works well
    on both. First, we should patch dsocks to use Tor's <i>mapaddress</i>
    commands from the controller interface, so we don't waste a whole
    round-trip inside Tor doing the resolve before connecting. Second,
    we should make our <i>torify</i> script detect which of torsocks or
    dsocks is installed, and call them appropriately. This probably means
    unifying their interfaces, and might involve sharing code between them
    or discarding one entirely.
    </li>
    
    <li>
    <b>Bring up new ideas!</b>
    <br>
    Don't like any of these? Look at the <a
    href="<gitblob>doc/roadmaps/2008-12-19-roadmap-full.pdf">Tor development
    roadmap</a> for more ideas, or just try out Tor, Vidalia, and Torbutton,
    and find out what you think needs fixing.
    Some of the <a href="<gittree>doc/spec/proposals">current proposals</a>
    might also be short on developers.
    </li>
    
    </ol>
    
    <a id="OtherCoding"></a>
    <h2><a class="anchor" href="#OtherCoding">Other Coding and Design related ideas</a></h2>
    <ol>
    <li>Tor relays don't work well on Windows XP. On
    Windows, Tor uses the standard <tt>select()</tt> system
    call, which uses space in the non-page pool. This means
    that a medium sized Tor relay will empty the non-page pool, <a
    href="https://trac.torproject.org/projects/tor/wiki/TheOnionRouter/WindowsBufferProblems">causing
    havoc and system crashes</a>. We should probably be using overlapped IO
    instead. One solution would be to teach <a
    href="http://www.monkey.org/~provos/libevent/">libevent</a> how to use
    overlapped IO rather than select() on Windows, and then adapt Tor to
    the new libevent interface. Christian King made a
    <a href="https://svn.torproject.org/svn/libevent-urz/trunk/">good
    start</a> on this in the summer of 2007.</li>
    
    <li>We need to actually start building our <a href="<page
    docs/documentation>#DesignDoc">blocking-resistance design</a>. This involves
    fleshing out the design, modifying many different pieces of Tor, adapting
    <a href="<page projects/vidalia>">Vidalia</a> so it supports the
    new features, and planning for deployment.</li>
    
    <li>We need a flexible simulator framework for studying end-to-end
    traffic confirmation attacks. Many researchers have whipped up ad hoc
    simulators to support their intuition either that the attacks work
    really well or that some defense works great. Can we build a simulator
    that's clearly documented and open enough that everybody knows it's
    giving a reasonable answer? This will spur a lot of new research.
    See the entry <a href="#Research">below</a> on confirmation attacks for
    details on the research side of this task &mdash; who knows, when it's
    done maybe you can help write a paper or three also.</li>
    
    <li>Tor 0.1.1.x and later include support for hardware crypto
    accelerators via OpenSSL. It has been lightly tested and is
    possibly very buggy.  We're looking for more rigorous testing,
    performance analysis, and optimally, code fixes to OpenSSL and
    Tor if needed.</li>
    
    <li>Perform a security analysis of Tor with <a
    href="http://en.wikipedia.org/wiki/Fuzz_testing">"fuzz"</a>. Determine
    if there are good fuzzing libraries out there for what we want. Win fame by
    getting credit when we put out a new release because of you!</li>
    
    <li>Tor uses TCP for transport and TLS for link
    encryption. This is nice and simple, but it means all cells
    on a link are delayed when a single packet gets dropped, and
    it means we can only reasonably support TCP streams. We have a <a
    href="https://trac.torproject.org/projects/tor/wiki/TheOnionRouter/TorFAQ#YoushouldtransportallIPpacketsnotjustTCPpackets.">list
    of reasons why we haven't shifted to UDP transport</a>, but it would
    be great to see that list get shorter. We also have a proposed <a
    href="<gitblob>doc/spec/proposals/100-tor-spec-udp.txt">specification
    for Tor and
    UDP</a> &mdash; please let us know what's wrong with it.</li>
    
    <li>We're not that far from having IPv6 support for destination addresses
    (at exit nodes). If you care strongly about IPv6, that's probably the
    first place to start.</li>
    
    <li>We need a way to generate the website diagrams (for example, the "How
    Tor Works" pictures on the <a href="<page about/overview>">overview page</a>
    from source, so we can translate them as UTF-8 text rather than edit
    them by hand with Gimp. We might want to
    integrate this as an wml file so translations are easy and images are
    generated in multiple languages whenever we build the website.</li>
    
    <li>How can we make the various LiveCD/USB systems easier
    to maintain, improve, and document?  One example is <a
    href="https://amnesia.boum.org/">The (Amnesic) Incognito Live
    System</a>.
    </li>
    
    <li>
    Another anti-censorship project is to try to make Tor
    more scanning-resistant.  Right now, an adversary can identify <a
    href="<gitblob>doc/spec/proposals/125-bridges.txt">Tor bridges</a>
    just by trying to connect to them, following the Tor protocol,
    and seeing if they respond.  To solve this, bridges could <a
    href="<svnprojects>design-paper/blocking.html#tth_sEc9.3">act like
    webservers</a> (HTTP or HTTPS) when contacted by port-scanning tools,
    and not act like bridges until the user provides a bridge-specific key.
    To start, check out Shane Pope's <a
    href="http://dl.dropbox.com/u/37735/index.html">thesis and prototype</a>.
    </li>
    
    </ol>
    
    <a id="Research"></a>
    <h2><a class="anchor" href="#Research">Research</a></h2>
    <ol>
    <li>The "end-to-end traffic confirmation attack":
    by watching traffic at Alice and at Bob, we can <a
    href="http://freehaven.net/anonbib/#danezis:pet2004">compare
    traffic signatures and become convinced that we're watching the same
    stream</a>. So far Tor accepts this as a fact of life and assumes this
    attack is trivial in all cases. First of all, is that actually true? How
    much traffic of what sort of distribution is needed before the adversary
    is confident he has won? Are there scenarios (e.g. not transmitting much)
    that slow down the attack? Do some traffic padding or traffic shaping
    schemes work better than others?</li>
    <li>A related question is: Does running a relay/bridge provide additional
    protection against these timing attacks? Can an external adversary that can't
    see inside TLS links still recognize individual streams reliably?
    Does the amount of traffic carried degrade this ability any? What if the
    client-relay deliberately delayed upstream relayed traffic to create a queue
    that could be used to mimic timings of client downstream traffic to make it
    look like it was also relayed? This same queue could also be used for masking
    timings in client upstream traffic with the techniques from <a
    href="http://www.freehaven.net/anonbib/#ShWa-Timing06">adaptive padding</a>,
    but without the need for additional traffic. Would such an interleaving of
    client upstream traffic obscure timings for external adversaries? Would the
    strategies need to be adjusted for asymmetric links? For example, on
    asymmetric links, is it actually possible to differentiate client traffic from
    natural bursts due to their asymmetric capacity? Or is it easier than
    symmetric links for some other reason?</li>
    <li>Repeat Murdoch and Danezis's <a
    href="http://www.cl.cam.ac.uk/~sjm217/projects/anon/#torta">attack from
    Oakland 05</a> on the current Tor network. See if you can learn why it
    works well on some nodes and not well on others. (My theory is that the
    fast nodes with spare capacity resist the attack better.) If that's true,
    then experiment with the RelayBandwidthRate and RelayBandwidthBurst
    options to run a relay that is used as a client while relaying the
    attacker's traffic: as we crank down the RelayBandwidthRate, does the
    attack get harder? What's the right ratio of RelayBandwidthRate to
    actually capacity? Or is it a ratio at all? While we're at it, does a
    much larger set of candidate relays increase the false positive rate
    or other complexity for the attack? (The Tor network is now almost two
    orders of magnitude larger than it was when they wrote their paper.) Be
    sure to read <a href="http://freehaven.net/anonbib/#clog-the-queue">Don't
    Clog the Queue</a> too.</li>
    <li>The "routing zones attack": most of the literature thinks of
    the network path between Alice and her entry node (and between the
    exit node and Bob) as a single link on some graph. In practice,
    though, the path traverses many autonomous systems (ASes), and <a
    href="http://freehaven.net/anonbib/#feamster:wpes2004">it's not uncommon
    that the same AS appears on both the entry path and the exit path</a>.
    Unfortunately, to accurately predict whether a given Alice, entry,
    exit, Bob quad will be dangerous, we need to download an entire Internet
    routing zone and perform expensive operations on it. Are there practical
    approximations, such as avoiding IP addresses in the same /8 network?</li>
    <li>Other research questions regarding geographic diversity consider
    the tradeoff between choosing an efficient circuit and choosing a random
    circuit. Look at Stephen Rollyson's <a
    href="http://swiki.cc.gatech.edu:8080/ugResearch/uploads/7/ImprovingTor.pdf">position
    paper</a> on how to discard particularly slow choices without hurting
    anonymity "too much". This line of reasoning needs more work and more
    thinking, but it looks very promising.</li>
    <li>Tor doesn't work very well when relays have asymmetric bandwidth
    (e.g. cable or DSL). Because Tor has separate TCP connections between
    each hop, if the incoming bytes are arriving just fine and the outgoing
    bytes are all getting dropped on the floor, the TCP push-back mechanisms
    don't really transmit this information back to the incoming streams.
    Perhaps Tor should detect when it's dropping a lot of outgoing packets,
    and rate-limit incoming streams to regulate this itself? I can imagine
    a build-up and drop-off scheme where we pick a conservative rate-limit,
    slowly increase it until we get lost packets, back off, repeat. We
    need somebody who's good with networks to simulate this and help design
    solutions; and/or we need to understand the extent of the performance
    degradation, and use this as motivation to reconsider UDP transport.</li>
    <li>A related topic is congestion control. Is our
    current design sufficient once we have heavy use? Maybe
    we should experiment with variable-sized windows rather
    than fixed-size windows? That seemed to go well in an <a
    href="http://www.psc.edu/networking/projects/hpn-ssh/theory.php">ssh
    throughput experiment</a>. We'll need to measure and tweak, and maybe
    overhaul if the results are good.</li>
    <li>Our censorship-resistance goals include preventing
    an attacker who's looking at Tor traffic on the wire from <a
    href="<svnprojects>design-paper/blocking.html#sec:network-fingerprint">distinguishing
    it from normal SSL traffic</a>. Obviously we can't achieve perfect
    steganography and still remain usable, but for a first step we'd like to
    block any attacks that can win by observing only a few packets. One of
    the remaining attacks we haven't examined much is that Tor cells are 512
    bytes, so the traffic on the wire may well be a multiple of 512 bytes.
    How much does the batching and overhead in TLS records blur this on the
    wire? Do different buffer flushing strategies in Tor affect this? Could
    a bit of padding help a lot, or is this an attack we must accept?</li>
    <li>Tor circuits are built one hop at a time, so in theory we have the
    ability to make some streams exit from the second hop, some from the
    third, and so on. This seems nice because it breaks up the set of exiting
    streams that a given relay can see. But if we want each stream to be safe,
    the "shortest" path should be at least 3 hops long by our current logic, so
    the rest will be even longer. We need to examine this performance / security
    tradeoff.</li>
    <li>It's not that hard to DoS Tor relays or directory authorities. Are client
    puzzles the right answer? What other practical approaches are there? Bonus
    if they're backward-compatible with the current Tor protocol.</li>
    <li>Programs like <a
    href="<page torbutton/index>">Torbutton</a> aim to hide
    your browser's UserAgent string by replacing it with a uniform answer for
    every Tor user. That way the attacker can't splinter Tor's anonymity set
    by looking at that header. It tries to pick a string that is commonly used
    by non-Tor users too, so it doesn't stand out. Question one: how badly
    do we hurt ourselves by periodically updating the version of Firefox
    that Torbutton claims to be? If we update it too often, we splinter the
    anonymity sets ourselves. If we don't update it often enough, then all the
    Tor users stand out because they claim to be running a quite old version
    of Firefox. The answer here probably depends on the Firefox versions seen
    in the wild. Question two: periodically people ask us to cycle through N
    UserAgent strings rather than stick with one. Does this approach help,
    hurt, or not matter? Consider: cookies and recognizing Torbutton users
    by their rotating UserAgents; malicious websites who only attack certain
    browsers; and whether the answers to question one impact this answer.
    </li>
    <li>How many bridge relays do you need to know to maintain
    reachability? We should measure the churn in our bridges. If there is
    lots of churn, are there ways to keep bridge users more likely to stay
    connected?
    </li>
    </ol>
    
    <p>
    <a href="<page about/contact>">Let us know</a> if you've made progress on any
    of these!
    </p>
  </div>
  <!-- END MAINCOL -->
  <div id = "sidecol">
#include "side.wmi"
#include "info.wmi"
  </div>
  <!-- END SIDECOL -->
</div>
<!-- END CONTENT -->
#include <foot.wmi>    
